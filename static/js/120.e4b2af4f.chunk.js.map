{"version":3,"file":"static/js/120.e4b2af4f.chunk.js","mappings":"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","sources":["../node_modules/web-tree-sitter/src/constants.ts","../node_modules/web-tree-sitter/src/lookahead_iterator.ts","../node_modules/web-tree-sitter/src/tree.ts","../node_modules/web-tree-sitter/src/tree_cursor.ts","../node_modules/web-tree-sitter/src/node.ts","../node_modules/web-tree-sitter/src/marshal.ts","../node_modules/web-tree-sitter/src/query.ts","../node_modules/web-tree-sitter/src/language.ts","../node_modules/web-tree-sitter/lib/tree-sitter.mjs","../node_modules/web-tree-sitter/src/bindings.ts","../node_modules/web-tree-sitter/src/parser.ts","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js"],"sourcesContent":["import { type MainModule } from '../lib/tree-sitter';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { ParseState, type Parser } from './parser';\n\n/**\n * A position in a multi-line text document, in terms of rows and columns.\n *\n * Rows and columns are zero-based.\n */\nexport interface Point {\n  /** The zero-based row number. */\n  row: number;\n\n  /** The zero-based column number. */\n  column: number;\n}\n\n/**\n *  A range of positions in a multi-line text document, both in terms of bytes\n *  and of rows and columns.\n */\nexport interface Range {\n  /** The start position of the range. */\n  startPosition: Point;\n\n  /** The end position of the range. */\n  endPosition: Point;\n\n  /** The start index of the range. */\n  startIndex: number;\n\n  /** The end index of the range. */\n  endIndex: number;\n}\n\n/**\n * A summary of a change to a text document.\n */\nexport interface Edit {\n  /** The start position of the change. */\n  startPosition: Point;\n\n  /** The end position of the change before the edit. */\n  oldEndPosition: Point;\n\n  /** The end position of the change after the edit. */\n  newEndPosition: Point;\n\n  /** The start index of the change. */\n  startIndex: number;\n\n  /** The end index of the change before the edit. */\n  oldEndIndex: number;\n\n  /** The end index of the change after the edit. */\n  newEndIndex: number;\n}\n\n/** @internal */\nexport const SIZE_OF_SHORT = 2;\n\n/** @internal */\nexport const SIZE_OF_INT = 4;\n\n/** @internal */\nexport const SIZE_OF_CURSOR = 4 * SIZE_OF_INT;\n\n/** @internal */\nexport const SIZE_OF_NODE = 5 * SIZE_OF_INT;\n\n/** @internal */\nexport const SIZE_OF_POINT = 2 * SIZE_OF_INT;\n\n/** @internal */\nexport const SIZE_OF_RANGE = 2 * SIZE_OF_INT + 2 * SIZE_OF_POINT;\n\n/** @internal */\nexport const ZERO_POINT: Point = { row: 0, column: 0 };\n\n/**\n * A callback for parsing that takes an index and point, and should return a string.\n */\nexport type ParseCallback = (index: number, position: Point) => string | undefined;\n\n/**\n  * A callback that receives the parse state during parsing.\n  */\nexport type ProgressCallback = (progress: ParseState) => boolean;\n\n/**\n * A callback for logging messages.\n *\n * If `isLex` is `true`, the message is from the lexer, otherwise it's from the parser.\n */\nexport type LogCallback = (message: string, isLex: boolean) => void;\n\n// Helper type for internal use\n/** @internal */\nexport const INTERNAL = Symbol('INTERNAL');\n/** @internal */\nexport type Internal = typeof INTERNAL;\n\n// Helper functions for type checking\n/** @internal */\nexport function assertInternal(x: unknown): asserts x is Internal {\n  if (x !== INTERNAL) throw new Error('Illegal constructor');\n}\n\n/** @internal */\nexport function isPoint(point?: Point): point is Point {\n  return (\n    !!point &&\n    typeof (point).row === 'number' &&\n    typeof (point).column === 'number'\n  );\n}\n\n/**\n * @internal\n *\n * Sets the Tree-sitter WASM module. This should only be called by the {@link Parser} class via {@link Parser.init}.\n */\nexport function setModule(module: MainModule) {\n  C = module;\n}\n\n/**\n * @internal\n *\n * `C` is a convenient shorthand for the Tree-sitter WASM module,\n * which allows us to call all of the exported functions.\n */\nexport let C: MainModule;\n","import { C, Internal, assertInternal } from './constants';\nimport { Language } from './language';\n\nexport class LookaheadIterator implements Iterable<string> {\n  /** @internal */\n  private [0] = 0; // Internal handle for WASM\n\n  /** @internal */\n  private language: Language;\n\n  /** @internal */\n  constructor(internal: Internal, address: number, language: Language) {\n    assertInternal(internal);\n    this[0] = address;\n    this.language = language;\n  }\n\n  /** Get the current symbol of the lookahead iterator. */\n  get currentTypeId(): number {\n    return C._ts_lookahead_iterator_current_symbol(this[0]);\n  }\n\n  /** Get the current symbol name of the lookahead iterator. */\n  get currentType(): string {\n    return this.language.types[this.currentTypeId] || 'ERROR';\n  }\n\n  /** Delete the lookahead iterator, freeing its resources. */\n  delete(): void {\n    C._ts_lookahead_iterator_delete(this[0]);\n    this[0] = 0;\n  }\n\n\n  /**\n   * Reset the lookahead iterator.\n   *\n   * This returns `true` if the language was set successfully and `false`\n   * otherwise.\n   */\n  reset(language: Language, stateId: number): boolean {\n    if (C._ts_lookahead_iterator_reset(this[0], language[0], stateId)) {\n      this.language = language;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Reset the lookahead iterator to another state.\n   *\n   * This returns `true` if the iterator was reset to the given state and\n   * `false` otherwise.\n   */\n  resetState(stateId: number): boolean {\n    return Boolean(C._ts_lookahead_iterator_reset_state(this[0], stateId));\n  }\n\n  /**\n   * Returns an iterator that iterates over the symbols of the lookahead iterator.\n   *\n   * The iterator will yield the current symbol name as a string for each step\n   * until there are no more symbols to iterate over.\n   */\n  [Symbol.iterator](): Iterator<string> {\n    return {\n      next: (): IteratorResult<string> => {\n        if (C._ts_lookahead_iterator_next(this[0])) {\n          return { done: false, value: this.currentType };\n        }\n        return { done: true, value: '' };\n      }\n    };\n  }\n}\n","import { INTERNAL, Internal, assertInternal, ParseCallback, Point, Range, Edit, SIZE_OF_NODE, SIZE_OF_INT, SIZE_OF_RANGE, C } from './constants';\nimport { Language } from './language';\nimport { Node } from './node';\nimport { TreeCursor } from './tree_cursor';\nimport { marshalEdit, marshalPoint, unmarshalNode, unmarshalRange } from './marshal';\nimport { TRANSFER_BUFFER } from './parser';\n\n/** @internal */\nexport function getText(tree: Tree, startIndex: number, endIndex: number, startPosition: Point): string {\n  const length = endIndex - startIndex;\n  let result = tree.textCallback(startIndex, startPosition);\n  if (result) {\n    startIndex += result.length;\n    while (startIndex < endIndex) {\n      const string = tree.textCallback(startIndex, startPosition);\n      if (string && string.length > 0) {\n        startIndex += string.length;\n        result += string;\n      } else {\n        break;\n      }\n    }\n    if (startIndex > endIndex) {\n      result = result.slice(0, length);\n    }\n  }\n  return result ?? '';\n}\n\n/** A tree that represents the syntactic structure of a source code file. */\nexport class Tree {\n  /** @internal */\n  private [0] = 0; // Internal handle for WASM\n\n  /** @internal */\n  textCallback: ParseCallback;\n\n  /** The language that was used to parse the syntax tree. */\n  language: Language;\n\n  /** @internal */\n  constructor(internal: Internal, address: number, language: Language, textCallback: ParseCallback) {\n    assertInternal(internal);\n    this[0] = address;\n    this.language = language;\n    this.textCallback = textCallback;\n  }\n\n  /** Create a shallow copy of the syntax tree. This is very fast. */\n  copy(): Tree {\n    const address = C._ts_tree_copy(this[0]);\n    return new Tree(INTERNAL, address, this.language, this.textCallback);\n  }\n\n  /** Delete the syntax tree, freeing its resources. */\n  delete(): void {\n    C._ts_tree_delete(this[0]);\n    this[0] = 0;\n  }\n\n  /** Get the root node of the syntax tree. */\n  get rootNode(): Node {\n    C._ts_tree_root_node_wasm(this[0]);\n    return unmarshalNode(this)!;\n  }\n\n  /**\n   * Get the root node of the syntax tree, but with its position shifted\n   * forward by the given offset.\n   */\n  rootNodeWithOffset(offsetBytes: number, offsetExtent: Point): Node {\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    C.setValue(address, offsetBytes, 'i32');\n    marshalPoint(address + SIZE_OF_INT, offsetExtent);\n    C._ts_tree_root_node_with_offset_wasm(this[0]);\n    return unmarshalNode(this)!;\n  }\n\n  /**\n   * Edit the syntax tree to keep it in sync with source code that has been\n   * edited.\n   *\n   * You must describe the edit both in terms of byte offsets and in terms of\n   * row/column coordinates.\n   */\n  edit(edit: Edit): void {\n    marshalEdit(edit);\n    C._ts_tree_edit_wasm(this[0]);\n  }\n\n  /** Create a new {@link TreeCursor} starting from the root of the tree. */\n  walk(): TreeCursor {\n    return this.rootNode.walk();\n  }\n\n  /**\n   * Compare this old edited syntax tree to a new syntax tree representing\n   * the same document, returning a sequence of ranges whose syntactic\n   * structure has changed.\n   *\n   * For this to work correctly, this syntax tree must have been edited such\n   * that its ranges match up to the new tree. Generally, you'll want to\n   * call this method right after calling one of the [`Parser::parse`]\n   * functions. Call it on the old tree that was passed to parse, and\n   * pass the new tree that was returned from `parse`.\n   */\n  getChangedRanges(other: Tree): Range[] {\n    if (!(other instanceof Tree)) {\n      throw new TypeError('Argument must be a Tree');\n    }\n\n    C._ts_tree_get_changed_ranges_wasm(this[0], other[0]);\n    const count = C.getValue(TRANSFER_BUFFER, 'i32');\n    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n    const result = new Array<Range>(count);\n\n    if (count > 0) {\n      let address = buffer;\n      for (let i = 0; i < count; i++) {\n        result[i] = unmarshalRange(address);\n        address += SIZE_OF_RANGE;\n      }\n      C._free(buffer);\n    }\n    return result;\n  }\n\n  /** Get the included ranges that were used to parse the syntax tree. */\n  getIncludedRanges(): Range[] {\n    C._ts_tree_included_ranges_wasm(this[0]);\n    const count = C.getValue(TRANSFER_BUFFER, 'i32');\n    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n    const result = new Array<Range>(count);\n\n    if (count > 0) {\n      let address = buffer;\n      for (let i = 0; i < count; i++) {\n        result[i] = unmarshalRange(address);\n        address += SIZE_OF_RANGE;\n      }\n      C._free(buffer);\n    }\n    return result;\n  }\n}\n","import { INTERNAL, Internal, assertInternal, Point, SIZE_OF_NODE, SIZE_OF_CURSOR, C } from './constants';\nimport { marshalNode, marshalPoint, marshalTreeCursor, unmarshalNode, unmarshalPoint, unmarshalTreeCursor } from './marshal';\nimport { Node } from './node';\nimport { TRANSFER_BUFFER } from './parser';\nimport { getText, Tree } from './tree';\n\n/** A stateful object for walking a syntax {@link Tree} efficiently. */\nexport class TreeCursor {\n  /** @internal */\n  // @ts-expect-error: never read\n  private [0] = 0; // Internal handle for Wasm\n\n  /** @internal */\n  // @ts-expect-error: never read\n  private [1] = 0; // Internal handle for Wasm\n\n  /** @internal */\n  // @ts-expect-error: never read\n  private [2] = 0; // Internal handle for Wasm\n\n  /** @internal */\n  // @ts-expect-error: never read\n  private [3] = 0; // Internal handle for Wasm\n\n  /** @internal */\n  private tree: Tree;\n\n  /** @internal */\n  constructor(internal: Internal, tree: Tree) {\n    assertInternal(internal);\n    this.tree = tree;\n    unmarshalTreeCursor(this);\n  }\n\n  /** Creates a deep copy of the tree cursor. This allocates new memory. */\n  copy(): TreeCursor {\n    const copy = new TreeCursor(INTERNAL, this.tree);\n    C._ts_tree_cursor_copy_wasm(this.tree[0]);\n    unmarshalTreeCursor(copy);\n    return copy;\n  }\n\n  /** Delete the tree cursor, freeing its resources. */\n  delete(): void {\n    marshalTreeCursor(this);\n    C._ts_tree_cursor_delete_wasm(this.tree[0]);\n    this[0] = this[1] = this[2] = 0;\n  }\n\n  /** Get the tree cursor's current {@link Node}. */\n  get currentNode(): Node {\n    marshalTreeCursor(this);\n    C._ts_tree_cursor_current_node_wasm(this.tree[0]);\n    return unmarshalNode(this.tree)!;\n  }\n\n  /**\n   * Get the numerical field id of this tree cursor's current node.\n   *\n   * See also {@link TreeCursor#currentFieldName}.\n   */\n  get currentFieldId(): number {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_field_id_wasm(this.tree[0]);\n  }\n\n  /** Get the field name of this tree cursor's current node. */\n  get currentFieldName(): string | null {\n    return this.tree.language.fields[this.currentFieldId];\n  }\n\n  /**\n   * Get the depth of the cursor's current node relative to the original\n   * node that the cursor was constructed with.\n   */\n  get currentDepth(): number {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_depth_wasm(this.tree[0]);\n  }\n\n  /**\n   * Get the index of the cursor's current node out of all of the\n   * descendants of the original node that the cursor was constructed with.\n   */\n  get currentDescendantIndex(): number {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_descendant_index_wasm(this.tree[0]);\n  }\n\n  /** Get the type of the cursor's current node. */\n  get nodeType(): string {\n    return this.tree.language.types[this.nodeTypeId] || 'ERROR';\n  }\n\n  /** Get the type id of the cursor's current node. */\n  get nodeTypeId(): number {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_node_type_id_wasm(this.tree[0]);\n  }\n\n  /** Get the state id of the cursor's current node. */\n  get nodeStateId(): number {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_node_state_id_wasm(this.tree[0]);\n  }\n\n  /** Get the id of the cursor's current node. */\n  get nodeId(): number {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_node_id_wasm(this.tree[0]);\n  }\n\n  /**\n   * Check if the cursor's current node is *named*.\n   *\n   * Named nodes correspond to named rules in the grammar, whereas\n   * *anonymous* nodes correspond to string literals in the grammar.\n   */\n  get nodeIsNamed(): boolean {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_node_is_named_wasm(this.tree[0]) === 1;\n  }\n\n  /**\n   * Check if the cursor's current node is *missing*.\n   *\n   * Missing nodes are inserted by the parser in order to recover from\n   * certain kinds of syntax errors.\n   */\n  get nodeIsMissing(): boolean {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_node_is_missing_wasm(this.tree[0]) === 1;\n  }\n\n  /** Get the string content of the cursor's current node. */\n  get nodeText(): string {\n    marshalTreeCursor(this);\n    const startIndex = C._ts_tree_cursor_start_index_wasm(this.tree[0]);\n    const endIndex = C._ts_tree_cursor_end_index_wasm(this.tree[0]);\n    C._ts_tree_cursor_start_position_wasm(this.tree[0]);\n    const startPosition = unmarshalPoint(TRANSFER_BUFFER);\n    return getText(this.tree, startIndex, endIndex, startPosition);\n  }\n\n  /** Get the start position of the cursor's current node. */\n  get startPosition(): Point {\n    marshalTreeCursor(this);\n    C._ts_tree_cursor_start_position_wasm(this.tree[0]);\n    return unmarshalPoint(TRANSFER_BUFFER);\n  }\n\n  /** Get the end position of the cursor's current node. */\n  get endPosition(): Point {\n    marshalTreeCursor(this);\n    C._ts_tree_cursor_end_position_wasm(this.tree[0]);\n    return unmarshalPoint(TRANSFER_BUFFER);\n  }\n\n  /** Get the start index of the cursor's current node. */\n  get startIndex(): number {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_start_index_wasm(this.tree[0]);\n  }\n\n  /** Get the end index of the cursor's current node. */\n  get endIndex(): number {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_end_index_wasm(this.tree[0]);\n  }\n\n  /**\n   * Move this cursor to the first child of its current node.\n   *\n   * This returns `true` if the cursor successfully moved, and returns\n   * `false` if there were no children.\n   */\n  gotoFirstChild(): boolean {\n    marshalTreeCursor(this);\n    const result = C._ts_tree_cursor_goto_first_child_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n\n  /**\n   * Move this cursor to the last child of its current node.\n   *\n   * This returns `true` if the cursor successfully moved, and returns\n   * `false` if there were no children.\n   *\n   * Note that this function may be slower than\n   * {@link TreeCursor#gotoFirstChild} because it needs to\n   * iterate through all the children to compute the child's position.\n   */\n  gotoLastChild(): boolean {\n    marshalTreeCursor(this);\n    const result = C._ts_tree_cursor_goto_last_child_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n\n  /**\n   * Move this cursor to the parent of its current node.\n   *\n   * This returns `true` if the cursor successfully moved, and returns\n   * `false` if there was no parent node (the cursor was already on the\n   * root node).\n   *\n   * Note that the node the cursor was constructed with is considered the root\n   * of the cursor, and the cursor cannot walk outside this node.\n   */\n  gotoParent(): boolean {\n    marshalTreeCursor(this);\n    const result = C._ts_tree_cursor_goto_parent_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n\n  /**\n   * Move this cursor to the next sibling of its current node.\n   *\n   * This returns `true` if the cursor successfully moved, and returns\n   * `false` if there was no next sibling node.\n   *\n   * Note that the node the cursor was constructed with is considered the root\n   * of the cursor, and the cursor cannot walk outside this node.\n   */\n  gotoNextSibling(): boolean {\n    marshalTreeCursor(this);\n    const result = C._ts_tree_cursor_goto_next_sibling_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n\n  /**\n   * Move this cursor to the previous sibling of its current node.\n   *\n   * This returns `true` if the cursor successfully moved, and returns\n   * `false` if there was no previous sibling node.\n   *\n   * Note that this function may be slower than\n   * {@link TreeCursor#gotoNextSibling} due to how node\n   * positions are stored. In the worst case, this will need to iterate\n   * through all the children up to the previous sibling node to recalculate\n   * its position. Also note that the node the cursor was constructed with is\n   * considered the root of the cursor, and the cursor cannot walk outside this node.\n   */\n  gotoPreviousSibling(): boolean {\n    marshalTreeCursor(this);\n    const result = C._ts_tree_cursor_goto_previous_sibling_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n\n  /**\n   * Move the cursor to the node that is the nth descendant of\n   * the original node that the cursor was constructed with, where\n   * zero represents the original node itself.\n   */\n  gotoDescendant(goalDescendantIndex: number): void {\n    marshalTreeCursor(this);\n    C._ts_tree_cursor_goto_descendant_wasm(this.tree[0], goalDescendantIndex);\n    unmarshalTreeCursor(this);\n  }\n\n  /**\n   * Move this cursor to the first child of its current node that contains or\n   * starts after the given byte offset.\n   *\n   * This returns `true` if the cursor successfully moved to a child node, and returns\n   * `false` if no such child was found.\n   */\n  gotoFirstChildForIndex(goalIndex: number): boolean {\n    marshalTreeCursor(this);\n    C.setValue(TRANSFER_BUFFER + SIZE_OF_CURSOR, goalIndex, 'i32');\n    const result = C._ts_tree_cursor_goto_first_child_for_index_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n\n  /**\n   * Move this cursor to the first child of its current node that contains or\n   * starts after the given byte offset.\n   *\n   * This returns the index of the child node if one was found, and returns\n   * `null` if no such child was found.\n   */\n  gotoFirstChildForPosition(goalPosition: Point): boolean {\n    marshalTreeCursor(this);\n    marshalPoint(TRANSFER_BUFFER + SIZE_OF_CURSOR, goalPosition);\n    const result = C._ts_tree_cursor_goto_first_child_for_position_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n\n  /**\n   * Re-initialize this tree cursor to start at the original node that the\n   * cursor was constructed with.\n   */\n  reset(node: Node): void {\n    marshalNode(node);\n    marshalTreeCursor(this, TRANSFER_BUFFER + SIZE_OF_NODE);\n    C._ts_tree_cursor_reset_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n  }\n\n  /**\n   * Re-initialize a tree cursor to the same position as another cursor.\n   *\n   * Unlike {@link TreeCursor#reset}, this will not lose parent\n   * information and allows reusing already created cursors.\n   */\n  resetTo(cursor: TreeCursor): void {\n    marshalTreeCursor(this, TRANSFER_BUFFER);\n    marshalTreeCursor(cursor, TRANSFER_BUFFER + SIZE_OF_CURSOR);\n    C._ts_tree_cursor_reset_to_wasm(this.tree[0], cursor.tree[0]);\n    unmarshalTreeCursor(this);\n  }\n}\n","import { INTERNAL, Internal, assertInternal, Point, Edit, SIZE_OF_INT, SIZE_OF_NODE, SIZE_OF_POINT, ZERO_POINT, isPoint, C } from './constants';\nimport { getText, Tree } from './tree';\nimport { TreeCursor } from './tree_cursor';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { Language } from './language';\nimport { marshalNode, marshalPoint, unmarshalNode, unmarshalPoint } from './marshal';\nimport { TRANSFER_BUFFER } from './parser';\n\n/** A single node within a syntax {@link Tree}. */\nexport class Node {\n  /** @internal */\n  // @ts-expect-error: never read\n  private [0] = 0; // Internal handle for Wasm\n\n  /** @internal */\n  private _children?: (Node | null)[];\n\n  /** @internal */\n  private _namedChildren?: (Node | null)[];\n\n  /** @internal */\n  constructor(\n    internal: Internal,\n    {\n      id,\n      tree,\n      startIndex,\n      startPosition,\n      other,\n    }: {\n      id: number;\n      tree: Tree;\n      startIndex: number;\n      startPosition: Point;\n      other: number;\n    }\n  ) {\n    assertInternal(internal);\n    this[0] = other;\n    this.id = id;\n    this.tree = tree;\n    this.startIndex = startIndex;\n    this.startPosition = startPosition;\n  }\n\n  /**\n   * The numeric id for this node that is unique.\n   *\n   * Within a given syntax tree, no two nodes have the same id. However:\n   *\n   * * If a new tree is created based on an older tree, and a node from the old tree is reused in\n   *   the process, then that node will have the same id in both trees.\n   *\n   * * A node not marked as having changes does not guarantee it was reused.\n   *\n   * * If a node is marked as having changed in the old tree, it will not be reused.\n   */\n  id: number;\n\n  /** The byte index where this node starts. */\n  startIndex: number;\n\n  /** The position where this node starts. */\n  startPosition: Point;\n\n  /** The tree that this node belongs to. */\n  tree: Tree;\n\n  /** Get this node's type as a numerical id. */\n  get typeId(): number {\n    marshalNode(this);\n    return C._ts_node_symbol_wasm(this.tree[0]);\n  }\n\n  /**\n   * Get the node's type as a numerical id as it appears in the grammar,\n   * ignoring aliases.\n   */\n  get grammarId(): number {\n    marshalNode(this);\n    return C._ts_node_grammar_symbol_wasm(this.tree[0]);\n  }\n\n  /** Get this node's type as a string. */\n  get type(): string {\n    return this.tree.language.types[this.typeId] || 'ERROR';\n  }\n\n  /**\n   * Get this node's symbol name as it appears in the grammar, ignoring\n   * aliases as a string.\n   */\n  get grammarType(): string {\n    return this.tree.language.types[this.grammarId] || 'ERROR';\n  }\n\n  /**\n   * Check if this node is *named*.\n   *\n   * Named nodes correspond to named rules in the grammar, whereas\n   * *anonymous* nodes correspond to string literals in the grammar.\n   */\n  get isNamed(): boolean {\n    marshalNode(this);\n    return C._ts_node_is_named_wasm(this.tree[0]) === 1;\n  }\n\n  /**\n   * Check if this node is *extra*.\n   *\n   * Extra nodes represent things like comments, which are not required\n   * by the grammar, but can appear anywhere.\n   */\n  get isExtra(): boolean {\n    marshalNode(this);\n    return C._ts_node_is_extra_wasm(this.tree[0]) === 1;\n  }\n\n  /**\n   * Check if this node represents a syntax error.\n   *\n   * Syntax errors represent parts of the code that could not be incorporated\n   * into a valid syntax tree.\n   */\n  get isError(): boolean {\n    marshalNode(this);\n    return C._ts_node_is_error_wasm(this.tree[0]) === 1;\n  }\n\n  /**\n   * Check if this node is *missing*.\n   *\n   * Missing nodes are inserted by the parser in order to recover from\n   * certain kinds of syntax errors.\n   */\n  get isMissing(): boolean {\n    marshalNode(this);\n    return C._ts_node_is_missing_wasm(this.tree[0]) === 1;\n  }\n\n  /** Check if this node has been edited. */\n  get hasChanges(): boolean {\n    marshalNode(this);\n    return C._ts_node_has_changes_wasm(this.tree[0]) === 1;\n  }\n\n  /**\n   * Check if this node represents a syntax error or contains any syntax\n   * errors anywhere within it.\n   */\n  get hasError(): boolean {\n    marshalNode(this);\n    return C._ts_node_has_error_wasm(this.tree[0]) === 1;\n  }\n\n  /** Get the byte index where this node ends. */\n  get endIndex(): number {\n    marshalNode(this);\n    return C._ts_node_end_index_wasm(this.tree[0]);\n  }\n\n  /** Get the position where this node ends. */\n  get endPosition(): Point {\n    marshalNode(this);\n    C._ts_node_end_point_wasm(this.tree[0]);\n    return unmarshalPoint(TRANSFER_BUFFER);\n  }\n\n  /** Get the string content of this node. */\n  get text(): string {\n    return getText(this.tree, this.startIndex, this.endIndex, this.startPosition);\n  }\n\n  /** Get this node's parse state. */\n  get parseState(): number {\n    marshalNode(this);\n    return C._ts_node_parse_state_wasm(this.tree[0]);\n  }\n\n  /** Get the parse state after this node. */\n  get nextParseState(): number {\n    marshalNode(this);\n    return C._ts_node_next_parse_state_wasm(this.tree[0]);\n  }\n\n  /** Check if this node is equal to another node. */\n  equals(other: Node): boolean {\n    return this.tree === other.tree && this.id === other.id;\n  }\n\n  /**\n   * Get the node's child at the given index, where zero represents the first child.\n   *\n   * This method is fairly fast, but its cost is technically log(n), so if\n   * you might be iterating over a long list of children, you should use\n   * {@link Node#children} instead.\n   */\n  child(index: number): Node | null {\n    marshalNode(this);\n    C._ts_node_child_wasm(this.tree[0], index);\n    return unmarshalNode(this.tree);\n  }\n\n  /**\n   * Get this node's *named* child at the given index.\n   *\n   * See also {@link Node#isNamed}.\n   * This method is fairly fast, but its cost is technically log(n), so if\n   * you might be iterating over a long list of children, you should use\n   * {@link Node#namedChildren} instead.\n   */\n  namedChild(index: number): Node | null {\n    marshalNode(this);\n    C._ts_node_named_child_wasm(this.tree[0], index);\n    return unmarshalNode(this.tree);\n  }\n\n  /**\n   * Get this node's child with the given numerical field id.\n   *\n   * See also {@link Node#childForFieldName}. You can\n   * convert a field name to an id using {@link Language#fieldIdForName}.\n   */\n  childForFieldId(fieldId: number): Node | null {\n    marshalNode(this);\n    C._ts_node_child_by_field_id_wasm(this.tree[0], fieldId);\n    return unmarshalNode(this.tree);\n  }\n\n  /**\n   * Get the first child with the given field name.\n   *\n   * If multiple children may have the same field name, access them using\n   * {@link Node#childrenForFieldName}.\n   */\n  childForFieldName(fieldName: string): Node | null {\n    const fieldId = this.tree.language.fields.indexOf(fieldName);\n    if (fieldId !== -1) return this.childForFieldId(fieldId);\n    return null;\n  }\n\n  /** Get the field name of this node's child at the given index. */\n  fieldNameForChild(index: number): string | null {\n    marshalNode(this);\n    const address = C._ts_node_field_name_for_child_wasm(this.tree[0], index);\n    if (!address) return null;\n    return C.AsciiToString(address);\n  }\n\n  /** Get the field name of this node's named child at the given index. */\n  fieldNameForNamedChild(index: number): string | null {\n    marshalNode(this);\n    const address = C._ts_node_field_name_for_named_child_wasm(this.tree[0], index);\n    if (!address) return null;\n    return C.AsciiToString(address);\n  }\n  /**\n   * Get an array of this node's children with a given field name.\n   *\n   * See also {@link Node#children}.\n   */\n  childrenForFieldName(fieldName: string): (Node | null)[] {\n    const fieldId = this.tree.language.fields.indexOf(fieldName);\n    if (fieldId !== -1 && fieldId !== 0) return this.childrenForFieldId(fieldId);\n    return [];\n  }\n\n  /**\n    * Get an array of this node's children with a given field id.\n    *\n    * See also {@link Node#childrenForFieldName}.\n    */\n  childrenForFieldId(fieldId: number): (Node | null)[] {\n    marshalNode(this);\n    C._ts_node_children_by_field_id_wasm(this.tree[0], fieldId);\n    const count = C.getValue(TRANSFER_BUFFER, 'i32');\n    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n    const result = new Array<Node | null>(count);\n\n    if (count > 0) {\n      let address = buffer;\n      for (let i = 0; i < count; i++) {\n        result[i] = unmarshalNode(this.tree, address);\n        address += SIZE_OF_NODE;\n      }\n      C._free(buffer);\n    }\n    return result;\n  }\n\n  /** Get the node's first child that contains or starts after the given byte offset. */\n  firstChildForIndex(index: number): Node | null {\n    marshalNode(this);\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    C.setValue(address, index, 'i32');\n    C._ts_node_first_child_for_byte_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /** Get the node's first named child that contains or starts after the given byte offset. */\n  firstNamedChildForIndex(index: number): Node | null {\n    marshalNode(this);\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    C.setValue(address, index, 'i32');\n    C._ts_node_first_named_child_for_byte_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /** Get this node's number of children. */\n  get childCount(): number {\n    marshalNode(this);\n    return C._ts_node_child_count_wasm(this.tree[0]);\n  }\n\n\n  /**\n   * Get this node's number of *named* children.\n   *\n   * See also {@link Node#isNamed}.\n   */\n  get namedChildCount(): number {\n    marshalNode(this);\n    return C._ts_node_named_child_count_wasm(this.tree[0]);\n  }\n\n  /** Get this node's first child. */\n  get firstChild(): Node | null {\n    return this.child(0);\n  }\n\n  /**\n   * Get this node's first named child.\n   *\n   * See also {@link Node#isNamed}.\n   */\n  get firstNamedChild(): Node | null {\n    return this.namedChild(0);\n  }\n\n  /** Get this node's last child. */\n  get lastChild(): Node | null {\n    return this.child(this.childCount - 1);\n  }\n\n  /**\n   * Get this node's last named child.\n   *\n   * See also {@link Node#isNamed}.\n   */\n  get lastNamedChild(): Node | null {\n    return this.namedChild(this.namedChildCount - 1);\n  }\n\n  /**\n   * Iterate over this node's children.\n   *\n   * If you're walking the tree recursively, you may want to use the\n   * {@link TreeCursor} APIs directly instead.\n   */\n  get children(): (Node | null)[] {\n    if (!this._children) {\n      marshalNode(this);\n      C._ts_node_children_wasm(this.tree[0]);\n      const count = C.getValue(TRANSFER_BUFFER, 'i32');\n      const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n      this._children = new Array<Node>(count);\n      if (count > 0) {\n        let address = buffer;\n        for (let i = 0; i < count; i++) {\n          this._children[i] = unmarshalNode(this.tree, address);\n          address += SIZE_OF_NODE;\n        }\n        C._free(buffer);\n      }\n    }\n    return this._children;\n  }\n\n  /**\n   * Iterate over this node's named children.\n   *\n   * See also {@link Node#children}.\n   */\n  get namedChildren(): (Node | null)[] {\n    if (!this._namedChildren) {\n      marshalNode(this);\n      C._ts_node_named_children_wasm(this.tree[0]);\n      const count = C.getValue(TRANSFER_BUFFER, 'i32');\n      const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n      this._namedChildren = new Array<Node>(count);\n      if (count > 0) {\n        let address = buffer;\n        for (let i = 0; i < count; i++) {\n          this._namedChildren[i] = unmarshalNode(this.tree, address);\n          address += SIZE_OF_NODE;\n        }\n        C._free(buffer);\n      }\n    }\n    return this._namedChildren;\n  }\n\n  /**\n   * Get the descendants of this node that are the given type, or in the given types array.\n   *\n   * The types array should contain node type strings, which can be retrieved from {@link Language#types}.\n   *\n   * Additionally, a `startPosition` and `endPosition` can be passed in to restrict the search to a byte range.\n   */\n  descendantsOfType(\n    types: string | string[],\n    startPosition: Point = ZERO_POINT,\n    endPosition: Point = ZERO_POINT\n  ): (Node | null)[] {\n    if (!Array.isArray(types)) types = [types];\n\n    // Convert the type strings to numeric type symbols\n    const symbols: number[] = [];\n    const typesBySymbol = this.tree.language.types;\n    for (const node_type of types) {\n      if (node_type == \"ERROR\") {\n        symbols.push(65535); // Internally, ts_builtin_sym_error is -1, which is UINT_16MAX\n      }\n    }\n    for (let i = 0, n = typesBySymbol.length; i < n; i++) {\n      if (types.includes(typesBySymbol[i])) {\n        symbols.push(i);\n      }\n    }\n\n    // Copy the array of symbols to the WASM heap\n    const symbolsAddress = C._malloc(SIZE_OF_INT * symbols.length);\n    for (let i = 0, n = symbols.length; i < n; i++) {\n      C.setValue(symbolsAddress + i * SIZE_OF_INT, symbols[i], 'i32');\n    }\n\n    // Call the C API to compute the descendants\n    marshalNode(this);\n    C._ts_node_descendants_of_type_wasm(\n      this.tree[0],\n      symbolsAddress,\n      symbols.length,\n      startPosition.row,\n      startPosition.column,\n      endPosition.row,\n      endPosition.column\n    );\n\n    // Instantiate the nodes based on the data returned\n    const descendantCount = C.getValue(TRANSFER_BUFFER, 'i32');\n    const descendantAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n    const result = new Array<Node | null>(descendantCount);\n    if (descendantCount > 0) {\n      let address = descendantAddress;\n      for (let i = 0; i < descendantCount; i++) {\n        result[i] = unmarshalNode(this.tree, address);\n        address += SIZE_OF_NODE;\n      }\n    }\n\n    // Free the intermediate buffers\n    C._free(descendantAddress);\n    C._free(symbolsAddress);\n    return result;\n  }\n\n  /** Get this node's next sibling. */\n  get nextSibling(): Node | null {\n    marshalNode(this);\n    C._ts_node_next_sibling_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /** Get this node's previous sibling. */\n  get previousSibling(): Node | null {\n    marshalNode(this);\n    C._ts_node_prev_sibling_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /**\n   * Get this node's next *named* sibling.\n   *\n   * See also {@link Node#isNamed}.\n   */\n  get nextNamedSibling(): Node | null {\n    marshalNode(this);\n    C._ts_node_next_named_sibling_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /**\n   * Get this node's previous *named* sibling.\n   *\n   * See also {@link Node#isNamed}.\n   */\n  get previousNamedSibling(): Node | null {\n    marshalNode(this);\n    C._ts_node_prev_named_sibling_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /** Get the node's number of descendants, including one for the node itself. */\n  get descendantCount(): number {\n    marshalNode(this);\n    return C._ts_node_descendant_count_wasm(this.tree[0]);\n  }\n\n  /**\n   * Get this node's immediate parent.\n   * Prefer {@link Node#childWithDescendant} for iterating over this node's ancestors.\n   */\n  get parent(): Node | null {\n    marshalNode(this);\n    C._ts_node_parent_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /**\n   * Get the node that contains `descendant`.\n   *\n   * Note that this can return `descendant` itself.\n   */\n  childWithDescendant(descendant: Node): Node | null {\n    marshalNode(this);\n    marshalNode(descendant, 1);\n    C._ts_node_child_with_descendant_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /** Get the smallest node within this node that spans the given byte range. */\n  descendantForIndex(start: number, end: number = start): Node | null {\n    if (typeof start !== 'number' || typeof end !== 'number') {\n      throw new Error('Arguments must be numbers');\n    }\n\n    marshalNode(this);\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    C.setValue(address, start, 'i32');\n    C.setValue(address + SIZE_OF_INT, end, 'i32');\n    C._ts_node_descendant_for_index_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /** Get the smallest named node within this node that spans the given byte range. */\n  namedDescendantForIndex(start: number, end: number = start): Node | null {\n    if (typeof start !== 'number' || typeof end !== 'number') {\n      throw new Error('Arguments must be numbers');\n    }\n\n    marshalNode(this);\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    C.setValue(address, start, 'i32');\n    C.setValue(address + SIZE_OF_INT, end, 'i32');\n    C._ts_node_named_descendant_for_index_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /** Get the smallest node within this node that spans the given point range. */\n  descendantForPosition(start: Point, end: Point = start) {\n    if (!isPoint(start) || !isPoint(end)) {\n      throw new Error('Arguments must be {row, column} objects');\n    }\n\n    marshalNode(this);\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    marshalPoint(address, start);\n    marshalPoint(address + SIZE_OF_POINT, end);\n    C._ts_node_descendant_for_position_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /** Get the smallest named node within this node that spans the given point range. */\n  namedDescendantForPosition(start: Point, end: Point = start) {\n    if (!isPoint(start) || !isPoint(end)) {\n      throw new Error('Arguments must be {row, column} objects');\n    }\n\n    marshalNode(this);\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    marshalPoint(address, start);\n    marshalPoint(address + SIZE_OF_POINT, end);\n    C._ts_node_named_descendant_for_position_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /**\n   * Create a new {@link TreeCursor} starting from this node.\n   *\n   * Note that the given node is considered the root of the cursor,\n   * and the cursor cannot walk outside this node.\n   */\n  walk(): TreeCursor {\n    marshalNode(this);\n    C._ts_tree_cursor_new_wasm(this.tree[0]);\n    return new TreeCursor(INTERNAL, this.tree);\n  }\n\n  /**\n   * Edit this node to keep it in-sync with source code that has been edited.\n   *\n   * This function is only rarely needed. When you edit a syntax tree with\n   * the {@link Tree#edit} method, all of the nodes that you retrieve from\n   * the tree afterward will already reflect the edit. You only need to\n   * use {@link Node#edit} when you have a specific {@link Node} instance that\n   * you want to keep and continue to use after an edit.\n   */\n  edit(edit: Edit) {\n    if (this.startIndex >= edit.oldEndIndex) {\n      this.startIndex = edit.newEndIndex + (this.startIndex - edit.oldEndIndex);\n      let subbedPointRow;\n      let subbedPointColumn;\n      if (this.startPosition.row > edit.oldEndPosition.row) {\n        subbedPointRow = this.startPosition.row - edit.oldEndPosition.row;\n        subbedPointColumn = this.startPosition.column;\n      } else {\n        subbedPointRow = 0;\n        subbedPointColumn = this.startPosition.column;\n        if (this.startPosition.column >= edit.oldEndPosition.column) {\n          subbedPointColumn =\n            this.startPosition.column - edit.oldEndPosition.column;\n        }\n      }\n\n      if (subbedPointRow > 0) {\n        this.startPosition.row += subbedPointRow;\n        this.startPosition.column = subbedPointColumn;\n      } else {\n        this.startPosition.column += subbedPointColumn;\n      }\n    } else if (this.startIndex > edit.startIndex) {\n      this.startIndex = edit.newEndIndex;\n      this.startPosition.row = edit.newEndPosition.row;\n      this.startPosition.column = edit.newEndPosition.column;\n    }\n  }\n\n  /** Get the S-expression representation of this node. */\n  toString(): string {\n    marshalNode(this);\n    const address = C._ts_node_to_string_wasm(this.tree[0]);\n    const result = C.AsciiToString(address);\n    C._free(address);\n    return result;\n  }\n}\n","import { Edit, INTERNAL, Point, Range, SIZE_OF_INT, SIZE_OF_NODE, SIZE_OF_POINT, C } from \"./constants\";\nimport { Node } from \"./node\";\nimport { Tree } from \"./tree\";\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { Query, QueryCapture, type QueryMatch } from \"./query\";\nimport { TreeCursor } from \"./tree_cursor\";\nimport { TRANSFER_BUFFER } from \"./parser\";\nimport { LanguageMetadata } from \"./language\";\n\n/**\n * @internal\n *\n * Unmarshals a {@link QueryMatch} to the transfer buffer.\n */\nexport function unmarshalCaptures(\n  query: Query,\n  tree: Tree,\n  address: number,\n  patternIndex: number,\n  result: QueryCapture[]\n) {\n  for (let i = 0, n = result.length; i < n; i++) {\n    const captureIndex = C.getValue(address, 'i32');\n    address += SIZE_OF_INT;\n    const node = unmarshalNode(tree, address)!;\n    address += SIZE_OF_NODE;\n    result[i] = {patternIndex, name: query.captureNames[captureIndex], node};\n  }\n  return address;\n}\n\n/**\n * @internal\n *\n * Marshals a {@link Node} to the transfer buffer.\n */\nexport function marshalNode(node: Node, index = 0) {\n  let address = TRANSFER_BUFFER + index * SIZE_OF_NODE;\n  C.setValue(address, node.id, 'i32');\n  address += SIZE_OF_INT;\n  C.setValue(address, node.startIndex, 'i32');\n  address += SIZE_OF_INT;\n  C.setValue(address, node.startPosition.row, 'i32');\n  address += SIZE_OF_INT;\n  C.setValue(address, node.startPosition.column, 'i32');\n  address += SIZE_OF_INT;\n  C.setValue(address, node[0], 'i32');\n}\n\n/**\n * @internal\n *\n * Unmarshals a {@link Node} from the transfer buffer.\n */\nexport function unmarshalNode(tree: Tree, address = TRANSFER_BUFFER): Node | null {\n  const id = C.getValue(address, 'i32');\n  address += SIZE_OF_INT;\n  if (id === 0) return null;\n\n  const index = C.getValue(address, 'i32');\n  address += SIZE_OF_INT;\n  const row = C.getValue(address, 'i32');\n  address += SIZE_OF_INT;\n  const column = C.getValue(address, 'i32');\n  address += SIZE_OF_INT;\n  const other = C.getValue(address, 'i32');\n\n  const result = new Node(INTERNAL, {\n    id,\n    tree,\n    startIndex: index,\n    startPosition: {row, column},\n    other,\n  });\n\n  return result;\n}\n\n/**\n * @internal\n *\n * Marshals a {@link TreeCursor} to the transfer buffer.\n */\nexport function marshalTreeCursor(cursor: TreeCursor, address = TRANSFER_BUFFER) {\n  C.setValue(address + 0 * SIZE_OF_INT, cursor[0], 'i32');\n  C.setValue(address + 1 * SIZE_OF_INT, cursor[1], 'i32');\n  C.setValue(address + 2 * SIZE_OF_INT, cursor[2], 'i32');\n  C.setValue(address + 3 * SIZE_OF_INT, cursor[3], 'i32');\n}\n\n/**\n * @internal\n *\n * Unmarshals a {@link TreeCursor} from the transfer buffer.\n */\nexport function unmarshalTreeCursor(cursor: TreeCursor) {\n  cursor[0] = C.getValue(TRANSFER_BUFFER + 0 * SIZE_OF_INT, 'i32');\n  cursor[1] = C.getValue(TRANSFER_BUFFER + 1 * SIZE_OF_INT, 'i32');\n  cursor[2] = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, 'i32');\n  cursor[3] = C.getValue(TRANSFER_BUFFER + 3 * SIZE_OF_INT, 'i32');\n}\n\n/**\n * @internal\n *\n * Marshals a {@link Point} to the transfer buffer.\n */\nexport function marshalPoint(address: number, point: Point): void {\n  C.setValue(address, point.row, 'i32');\n  C.setValue(address + SIZE_OF_INT, point.column, 'i32');\n}\n\n/**\n * @internal\n *\n * Unmarshals a {@link Point} from the transfer buffer.\n */\nexport function unmarshalPoint(address: number): Point {\n  const result = {\n    row: C.getValue(address, 'i32') >>> 0,\n    column: C.getValue(address + SIZE_OF_INT, 'i32') >>> 0,\n  };\n  return result;\n}\n\n/**\n * @internal\n *\n * Marshals a {@link Range} to the transfer buffer.\n */\nexport function marshalRange(address: number, range: Range): void {\n  marshalPoint(address, range.startPosition); address += SIZE_OF_POINT;\n  marshalPoint(address, range.endPosition); address += SIZE_OF_POINT;\n  C.setValue(address, range.startIndex, 'i32'); address += SIZE_OF_INT;\n  C.setValue(address, range.endIndex, 'i32'); address += SIZE_OF_INT;\n}\n\n/**\n * @internal\n *\n * Unmarshals a {@link Range} from the transfer buffer.\n */\nexport function unmarshalRange(address: number): Range {\n  const result = {} as Range;\n  result.startPosition = unmarshalPoint(address); address += SIZE_OF_POINT;\n  result.endPosition = unmarshalPoint(address); address += SIZE_OF_POINT;\n  result.startIndex = C.getValue(address, 'i32') >>> 0; address += SIZE_OF_INT;\n  result.endIndex = C.getValue(address, 'i32') >>> 0;\n  return result;\n}\n\n/**\n * @internal\n *\n * Marshals an {@link Edit} to the transfer buffer.\n */\nexport function marshalEdit(edit: Edit, address = TRANSFER_BUFFER) {\n  marshalPoint(address, edit.startPosition); address += SIZE_OF_POINT;\n  marshalPoint(address, edit.oldEndPosition); address += SIZE_OF_POINT;\n  marshalPoint(address, edit.newEndPosition); address += SIZE_OF_POINT;\n  C.setValue(address, edit.startIndex, 'i32'); address += SIZE_OF_INT;\n  C.setValue(address, edit.oldEndIndex, 'i32'); address += SIZE_OF_INT;\n  C.setValue(address, edit.newEndIndex, 'i32'); address += SIZE_OF_INT;\n}\n\n/**\n * @internal\n *\n * Unmarshals a {@link LanguageMetadata} from the transfer buffer.\n */\nexport function unmarshalLanguageMetadata(address: number): LanguageMetadata {  \n  const major_version = C.getValue(address, 'i32');\n  const minor_version = C.getValue(address += SIZE_OF_INT, 'i32');\n  const patch_version = C.getValue(address += SIZE_OF_INT, 'i32');\n  return { major_version, minor_version, patch_version };\n}\n","import { Point, ZERO_POINT, SIZE_OF_INT, C } from './constants';\nimport { Node } from './node';\nimport { marshalNode, unmarshalCaptures } from './marshal';\nimport { TRANSFER_BUFFER } from './parser';\nimport { Language } from './language';\n\nconst PREDICATE_STEP_TYPE_CAPTURE = 1;\n\nconst PREDICATE_STEP_TYPE_STRING = 2;\n\nconst QUERY_WORD_REGEX = /[\\w-]+/g;\n\n/**\n * Options for query execution\n */\nexport interface QueryOptions {\n  /** The start position of the range to query */\n  startPosition?: Point;\n\n  /** The end position of the range to query */\n  endPosition?: Point;\n\n  /** The start index of the range to query */\n  startIndex?: number;\n\n  /** The end index of the range to query */\n  endIndex?: number;\n\n  /**\n   * The maximum number of in-progress matches for this query.\n   * The limit must be > 0 and <= 65536.\n   */\n  matchLimit?: number;\n\n  /**\n   * The maximum start depth for a query cursor.\n   *\n   * This prevents cursors from exploring children nodes at a certain depth.\n   * Note if a pattern includes many children, then they will still be\n   * checked.\n   *\n   * The zero max start depth value can be used as a special behavior and\n   * it helps to destructure a subtree by staying on a node and using\n   * captures for interested parts. Note that the zero max start depth\n   * only limit a search depth for a pattern's root node but other nodes\n   * that are parts of the pattern may be searched at any depth what\n   * defined by the pattern structure.\n   *\n   * Set to `null` to remove the maximum start depth.\n   */\n  maxStartDepth?: number;\n\n  /**\n   * The maximum duration in microseconds that query execution should be allowed to\n   * take before halting.\n   *\n   * If query execution takes longer than this, it will halt early, returning an empty array.\n   */\n  timeoutMicros?: number;\n\n  /**\n   * A function that will be called periodically during the execution of the query to check\n   * if query execution should be cancelled. You can also use this to instrument query execution\n   * and check where the query is at in the document. The progress callback takes a single argument,\n   * which is a {@link QueryState} representing the current state of the query.\n   */\n  progressCallback?: (state: QueryState) => void;\n}\n\n/**\n * A stateful object that is passed into the progress callback {@link QueryOptions#progressCallback}\n * to provide the current state of the query.\n */\nexport interface QueryState {\n  /** The byte offset in the document that the query is at. */\n  currentOffset: number;\n}\n\n/** A record of key-value pairs associated with a particular pattern in a {@link Query}. */\nexport type QueryProperties = Record<string, string | null>;\n\n/**\n * A predicate that contains an operator and list of operands.\n */\nexport interface QueryPredicate {\n  /** The operator of the predicate, like `match?`, `eq?`, `set!`, etc. */\n  operator: string;\n\n  /** The operands of the predicate, which are either captures or strings. */\n  operands: PredicateStep[];\n}\n\n/**\n * A particular {@link Node} that has been captured with a particular name within a\n * {@link Query}.\n */\nexport interface QueryCapture {\n  /** The index of the pattern that matched. */\n  patternIndex: number;\n\n  /** The name of the capture */\n  name: string;\n\n  /** The captured node */\n  node: Node;\n\n  /** The properties for predicates declared with the operator `set!`. */\n  setProperties?: QueryProperties;\n\n  /** The properties for predicates declared with the operator `is?`. */\n  assertedProperties?: QueryProperties;\n\n  /** The properties for predicates declared with the operator `is-not?`. */\n  refutedProperties?: QueryProperties;\n}\n\n/** A match of a {@link Query} to a particular set of {@link Node}s. */\nexport interface QueryMatch {\n  /** @deprecated since version 0.25.0, use `patternIndex` instead. */\n  pattern: number;\n\n  /** The index of the pattern that matched. */\n  patternIndex: number;\n\n  /** The captures associated with the match. */\n  captures: QueryCapture[];\n\n  /** The properties for predicates declared with the operator `set!`. */\n  setProperties?: QueryProperties;\n\n  /** The properties for predicates declared with the operator `is?`. */\n  assertedProperties?: QueryProperties;\n\n  /** The properties for predicates declared with the operator `is-not?`. */\n  refutedProperties?: QueryProperties;\n}\n\n/** A quantifier for captures */\nexport const CaptureQuantifier = {\n  Zero: 0,\n  ZeroOrOne: 1,\n  ZeroOrMore: 2,\n  One: 3,\n  OneOrMore: 4\n} as const;\n\n/** A quantifier for captures */\nexport type CaptureQuantifier = typeof CaptureQuantifier[keyof typeof CaptureQuantifier];\n\n/**\n * Predicates are represented as a single array of steps. There are two\n * types of steps, which correspond to the two legal values for\n * the `type` field:\n *\n * - `CapturePredicateStep` - Steps with this type represent names\n *    of captures.\n *\n * - `StringPredicateStep` - Steps with this type represent literal\n *    strings.\n */\nexport type PredicateStep = CapturePredicateStep | StringPredicateStep;\n\n/**\n * A step in a predicate that refers to a capture.\n *\n * The `name` field is the name of the capture.\n */\nexport interface CapturePredicateStep { type: 'capture', name: string }\n\n/**\n * A step in a predicate that refers to a string.\n *\n * The `value` field is the string value.\n */\nexport interface StringPredicateStep { type: 'string', value: string }\n\nconst isCaptureStep = (step: PredicateStep): step is Extract<PredicateStep, { type: 'capture' }> =>\n  step.type === 'capture';\n\nconst isStringStep = (step: PredicateStep): step is Extract<PredicateStep, { type: 'string' }> =>\n  step.type === 'string';\n\n/**\n * @internal\n *\n * A function that checks if a given set of captures matches a particular\n * condition. This is used in the built-in `eq?`, `match?`, and `any-of?`\n * predicates.\n */\nexport type TextPredicate = (captures: QueryCapture[]) => boolean;\n\n/** Error codes returned from tree-sitter query parsing */\nexport const QueryErrorKind = {\n  Syntax: 1,\n  NodeName: 2,\n  FieldName: 3,\n  CaptureName: 4,\n  PatternStructure: 5,\n} as const;\n\n/** An error that occurred while parsing a query string. */\nexport type QueryErrorKind = typeof QueryErrorKind[keyof typeof QueryErrorKind];\n\n/** Information about a {@link QueryError}. */\nexport interface QueryErrorInfo {\n  [QueryErrorKind.NodeName]: { word: string };\n  [QueryErrorKind.FieldName]: { word: string };\n  [QueryErrorKind.CaptureName]: { word: string };\n  [QueryErrorKind.PatternStructure]: { suffix: string };\n  [QueryErrorKind.Syntax]: { suffix: string };\n}\n\n/** Error thrown when parsing a tree-sitter query fails */\nexport class QueryError extends Error {\n  constructor(\n    public kind: QueryErrorKind,\n    public info: QueryErrorInfo[typeof kind],\n    public index: number,\n    public length: number\n  ) {\n    super(QueryError.formatMessage(kind, info));\n    this.name = 'QueryError';\n  }\n\n  /** Formats an error message based on the error kind and info */\n  private static formatMessage(kind: QueryErrorKind, info: QueryErrorInfo[QueryErrorKind]): string {\n    switch (kind) {\n      case QueryErrorKind.NodeName:\n        return `Bad node name '${(info as QueryErrorInfo[2]).word}'`;\n      case QueryErrorKind.FieldName:\n        return `Bad field name '${(info as QueryErrorInfo[3]).word}'`;\n      case QueryErrorKind.CaptureName:\n        return `Bad capture name @${(info as QueryErrorInfo[4]).word}`;\n      case QueryErrorKind.PatternStructure:\n        return `Bad pattern structure at offset ${(info as QueryErrorInfo[5]).suffix}`;\n      case QueryErrorKind.Syntax:\n        return `Bad syntax at offset ${(info as QueryErrorInfo[1]).suffix}`;\n    }\n  }\n}\n\n/**\n * Parses the `eq?` and `not-eq?` predicates in a query, and updates the text predicates.\n */\nfunction parseAnyPredicate(\n  steps: PredicateStep[],\n  index: number,\n  operator: string,\n  textPredicates: TextPredicate[][],\n) {\n  if (steps.length !== 3) {\n    throw new Error(\n      `Wrong number of arguments to \\`#${operator}\\` predicate. Expected 2, got ${steps.length - 1}`\n    );\n  }\n\n  if (!isCaptureStep(steps[1])) {\n    throw new Error(\n      `First argument of \\`#${operator}\\` predicate must be a capture. Got \"${steps[1].value}\"`\n    );\n  }\n\n  const isPositive = operator === 'eq?' || operator === 'any-eq?';\n  const matchAll = !operator.startsWith('any-');\n\n  if (isCaptureStep(steps[2])) {\n    const captureName1 = steps[1].name;\n    const captureName2 = steps[2].name;\n    textPredicates[index].push((captures) => {\n      const nodes1: Node[] = [];\n      const nodes2: Node[] = [];\n      for (const c of captures) {\n        if (c.name === captureName1) nodes1.push(c.node);\n        if (c.name === captureName2) nodes2.push(c.node);\n      }\n      const compare = (n1: { text: string }, n2: { text: string }, positive: boolean) => {\n        return positive ? n1.text === n2.text : n1.text !== n2.text;\n      };\n      return matchAll\n        ? nodes1.every((n1) => nodes2.some((n2) => compare(n1, n2, isPositive)))\n        : nodes1.some((n1) => nodes2.some((n2) => compare(n1, n2, isPositive)));\n    });\n  } else {\n    const captureName = steps[1].name;\n    const stringValue = steps[2].value;\n    const matches = (n: Node) => n.text === stringValue;\n    const doesNotMatch = (n: Node) => n.text !== stringValue;\n    textPredicates[index].push((captures) => {\n      const nodes = [];\n      for (const c of captures) {\n        if (c.name === captureName) nodes.push(c.node);\n      }\n      const test = isPositive ? matches : doesNotMatch;\n      return matchAll ? nodes.every(test) : nodes.some(test);\n    });\n  }\n}\n\n/**\n * Parses the `match?` and `not-match?` predicates in a query, and updates the text predicates.\n */\nfunction parseMatchPredicate(\n  steps: PredicateStep[],\n  index: number,\n  operator: string,\n  textPredicates: TextPredicate[][],\n) {\n  if (steps.length !== 3) {\n    throw new Error(\n      `Wrong number of arguments to \\`#${operator}\\` predicate. Expected 2, got ${steps.length - 1}.`,\n    );\n  }\n\n  if (steps[1].type !== 'capture') {\n    throw new Error(\n      `First argument of \\`#${operator}\\` predicate must be a capture. Got \"${steps[1].value}\".`,\n    );\n  }\n\n  if (steps[2].type !== 'string') {\n    throw new Error(\n      `Second argument of \\`#${operator}\\` predicate must be a string. Got @${steps[2].name}.`,\n    );\n  }\n\n  const isPositive = operator === 'match?' || operator === 'any-match?';\n  const matchAll = !operator.startsWith('any-');\n  const captureName = steps[1].name;\n  const regex = new RegExp(steps[2].value);\n  textPredicates[index].push((captures) => {\n    const nodes = [];\n    for (const c of captures) {\n      if (c.name === captureName) nodes.push(c.node.text);\n    }\n    const test = (text: string, positive: boolean) => {\n      return positive ?\n        regex.test(text) :\n        !regex.test(text);\n    };\n    if (nodes.length === 0) return !isPositive;\n    return matchAll ?\n      nodes.every((text) => test(text, isPositive)) :\n      nodes.some((text) => test(text, isPositive));\n  });\n}\n\n/**\n * Parses the `any-of?` and `not-any-of?` predicates in a query, and updates the text predicates.\n */\nfunction parseAnyOfPredicate(\n  steps: PredicateStep[],\n  index: number,\n  operator: string,\n  textPredicates: TextPredicate[][],\n) {\n  if (steps.length < 2) {\n    throw new Error(\n      `Wrong number of arguments to \\`#${operator}\\` predicate. Expected at least 1. Got ${steps.length - 1}.`,\n    );\n  }\n\n  if (steps[1].type !== 'capture') {\n    throw new Error(\n      `First argument of \\`#${operator}\\` predicate must be a capture. Got \"${steps[1].value}\".`,\n    );\n  }\n\n  const isPositive = operator === 'any-of?';\n  const captureName = steps[1].name;\n\n  const stringSteps = steps.slice(2);\n  if (!stringSteps.every(isStringStep)) {\n    throw new Error(\n      `Arguments to \\`#${operator}\\` predicate must be strings.\".`,\n    );\n  }\n  const values = stringSteps.map((s) => s.value);\n\n  textPredicates[index].push((captures) => {\n    const nodes = [];\n    for (const c of captures) {\n      if (c.name === captureName) nodes.push(c.node.text);\n    }\n    if (nodes.length === 0) return !isPositive;\n    return nodes.every((text) => values.includes(text)) === isPositive;\n  });\n}\n\n/**\n * Parses the `is?` and `is-not?` predicates in a query, and updates the asserted or refuted properties,\n * depending on if the operator is positive or negative.\n */\nfunction parseIsPredicate(\n  steps: PredicateStep[],\n  index: number,\n  operator: string,\n  assertedProperties: QueryProperties[],\n  refutedProperties: QueryProperties[],\n) {\n  if (steps.length < 2 || steps.length > 3) {\n    throw new Error(\n      `Wrong number of arguments to \\`#${operator}\\` predicate. Expected 1 or 2. Got ${steps.length - 1}.`,\n    );\n  }\n\n  if (!steps.every(isStringStep)) {\n    throw new Error(\n      `Arguments to \\`#${operator}\\` predicate must be strings.\".`,\n    );\n  }\n\n  const properties = operator === 'is?' ? assertedProperties : refutedProperties;\n  if (!properties[index]) properties[index] = {};\n  properties[index][steps[1].value] = steps[2]?.value ?? null;\n}\n\n/**\n * Parses the `set!` directive in a query, and updates the set properties.\n */\nfunction parseSetDirective(\n  steps: PredicateStep[],\n  index: number,\n  setProperties: QueryProperties[],\n) {\n  if (steps.length < 2 || steps.length > 3) {\n    throw new Error(`Wrong number of arguments to \\`#set!\\` predicate. Expected 1 or 2. Got ${steps.length - 1}.`);\n  }\n  if (!steps.every(isStringStep)) {\n    throw new Error(`Arguments to \\`#set!\\` predicate must be strings.\".`);\n  }\n  if (!setProperties[index]) setProperties[index] = {};\n  setProperties[index][steps[1].value] = steps[2]?.value ?? null;\n}\n\n/**\n * Parses the predicate at a given step in a pattern, and updates the appropriate\n * predicates or properties.\n */\nfunction parsePattern(\n  index: number,\n  stepType: number,\n  stepValueId: number,\n  captureNames: string[],\n  stringValues: string[],\n  steps: PredicateStep[],\n  textPredicates: TextPredicate[][],\n  predicates: QueryPredicate[][],\n  setProperties: QueryProperties[],\n  assertedProperties: QueryProperties[],\n  refutedProperties: QueryProperties[],\n) {\n  if (stepType === PREDICATE_STEP_TYPE_CAPTURE) {\n    const name = captureNames[stepValueId];\n    steps.push({ type: 'capture', name });\n  } else if (stepType === PREDICATE_STEP_TYPE_STRING) {\n    steps.push({ type: 'string', value: stringValues[stepValueId] });\n  } else if (steps.length > 0) {\n    if (steps[0].type !== 'string') {\n      throw new Error('Predicates must begin with a literal value');\n    }\n\n    const operator = steps[0].value;\n    switch (operator) {\n      case 'any-not-eq?':\n      case 'not-eq?':\n      case 'any-eq?':\n      case 'eq?':\n        parseAnyPredicate(steps, index, operator, textPredicates);\n        break;\n\n      case 'any-not-match?':\n      case 'not-match?':\n      case 'any-match?':\n      case 'match?':\n        parseMatchPredicate(steps, index, operator, textPredicates);\n        break;\n\n      case 'not-any-of?':\n      case 'any-of?':\n        parseAnyOfPredicate(steps, index, operator, textPredicates);\n        break;\n\n      case 'is?':\n      case 'is-not?':\n        parseIsPredicate(steps, index, operator, assertedProperties, refutedProperties);\n        break;\n\n      case 'set!':\n        parseSetDirective(steps, index, setProperties);\n        break;\n\n      default:\n        predicates[index].push({ operator, operands: steps.slice(1) });\n    }\n\n    steps.length = 0;\n  }\n}\n\nexport class Query {\n  /** @internal */\n  private [0] = 0; // Internal handle for WASM\n\n  /** @internal */\n  private exceededMatchLimit: boolean;\n\n  /** @internal */\n  private textPredicates: TextPredicate[][];\n\n  /** The names of the captures used in the query. */\n  readonly captureNames: string[];\n\n  /** The quantifiers of the captures used in the query. */\n  readonly captureQuantifiers: CaptureQuantifier[][];\n\n  /**\n   * The other user-defined predicates associated with the given index.\n   *\n   * This includes predicates with operators other than:\n   * - `match?`\n   * - `eq?` and `not-eq?`\n   * - `any-of?` and `not-any-of?`\n   * - `is?` and `is-not?`\n   * - `set!`\n   */\n  readonly predicates: QueryPredicate[][];\n\n  /** The properties for predicates with the operator `set!`. */\n  readonly setProperties: QueryProperties[];\n\n  /** The properties for predicates with the operator `is?`. */\n  readonly assertedProperties: QueryProperties[];\n\n  /** The properties for predicates with the operator `is-not?`. */\n  readonly refutedProperties: QueryProperties[];\n\n  /** The maximum number of in-progress matches for this cursor. */\n  matchLimit?: number;\n\n  /**\n   * Create a new query from a string containing one or more S-expression\n   * patterns.\n   *\n   * The query is associated with a particular language, and can only be run\n   * on syntax nodes parsed with that language. References to Queries can be\n   * shared between multiple threads.\n   *\n   * @link {@see https://tree-sitter.github.io/tree-sitter/using-parsers/queries}\n   */\n  constructor(language: Language, source: string) {\n    const sourceLength = C.lengthBytesUTF8(source);\n    const sourceAddress = C._malloc(sourceLength + 1);\n    C.stringToUTF8(source, sourceAddress, sourceLength + 1);\n    const address = C._ts_query_new(\n      language[0],\n      sourceAddress,\n      sourceLength,\n      TRANSFER_BUFFER,\n      TRANSFER_BUFFER + SIZE_OF_INT\n    );\n\n    if (!address) {\n      const errorId = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32') as QueryErrorKind;\n      const errorByte = C.getValue(TRANSFER_BUFFER, 'i32');\n      const errorIndex = C.UTF8ToString(sourceAddress, errorByte).length;\n      const suffix = source.slice(errorIndex, errorIndex + 100).split('\\n')[0];\n      const word = suffix.match(QUERY_WORD_REGEX)?.[0] ?? '';\n      C._free(sourceAddress);\n\n      switch (errorId) {\n        case QueryErrorKind.Syntax:\n          throw new QueryError(QueryErrorKind.Syntax, { suffix: `${errorIndex}: '${suffix}'...` }, errorIndex, 0);\n        case QueryErrorKind.NodeName:\n          throw new QueryError(errorId, { word }, errorIndex, word.length);\n        case QueryErrorKind.FieldName:\n          throw new QueryError(errorId, { word }, errorIndex, word.length);\n        case QueryErrorKind.CaptureName:\n          throw new QueryError(errorId, { word }, errorIndex, word.length);\n        case QueryErrorKind.PatternStructure:\n          throw new QueryError(errorId, { suffix: `${errorIndex}: '${suffix}'...` }, errorIndex, 0);\n      }\n    }\n\n    const stringCount = C._ts_query_string_count(address);\n    const captureCount = C._ts_query_capture_count(address);\n    const patternCount = C._ts_query_pattern_count(address);\n    const captureNames = new Array<string>(captureCount);\n    const captureQuantifiers = new Array<CaptureQuantifier[]>(patternCount);\n    const stringValues = new Array<string>(stringCount);\n\n    // Fill in the capture names\n    for (let i = 0; i < captureCount; i++) {\n      const nameAddress = C._ts_query_capture_name_for_id(\n        address,\n        i,\n        TRANSFER_BUFFER\n      );\n      const nameLength = C.getValue(TRANSFER_BUFFER, 'i32');\n      captureNames[i] = C.UTF8ToString(nameAddress, nameLength);\n    }\n\n    // Fill in the capture quantifiers\n    for (let i = 0; i < patternCount; i++) {\n      const captureQuantifiersArray = new Array<CaptureQuantifier>(captureCount);\n      for (let j = 0; j < captureCount; j++) {\n        const quantifier = C._ts_query_capture_quantifier_for_id(address, i, j);\n        captureQuantifiersArray[j] = quantifier as CaptureQuantifier;\n      }\n      captureQuantifiers[i] = captureQuantifiersArray;\n    }\n\n    // Fill in the string values\n    for (let i = 0; i < stringCount; i++) {\n      const valueAddress = C._ts_query_string_value_for_id(\n        address,\n        i,\n        TRANSFER_BUFFER\n      );\n      const nameLength = C.getValue(TRANSFER_BUFFER, 'i32');\n      stringValues[i] = C.UTF8ToString(valueAddress, nameLength);\n    }\n\n    const setProperties = new Array<QueryProperties>(patternCount);\n    const assertedProperties = new Array<QueryProperties>(patternCount);\n    const refutedProperties = new Array<QueryProperties>(patternCount);\n    const predicates = new Array<QueryPredicate[]>(patternCount);\n    const textPredicates = new Array<TextPredicate[]>(patternCount);\n\n    // Parse the predicates, and add the appropriate predicates or properties\n    for (let i = 0; i < patternCount; i++) {\n      const predicatesAddress = C._ts_query_predicates_for_pattern(address, i, TRANSFER_BUFFER);\n      const stepCount = C.getValue(TRANSFER_BUFFER, 'i32');\n\n      predicates[i] = [];\n      textPredicates[i] = [];\n\n      const steps = new Array<PredicateStep>();\n\n      let stepAddress = predicatesAddress;\n      for (let j = 0; j < stepCount; j++) {\n        const stepType = C.getValue(stepAddress, 'i32');\n        stepAddress += SIZE_OF_INT;\n\n        const stepValueId = C.getValue(stepAddress, 'i32');\n        stepAddress += SIZE_OF_INT;\n\n        parsePattern(\n          i,\n          stepType,\n          stepValueId,\n          captureNames,\n          stringValues,\n          steps,\n          textPredicates,\n          predicates,\n          setProperties,\n          assertedProperties,\n          refutedProperties,\n        );\n      }\n\n      Object.freeze(textPredicates[i]);\n      Object.freeze(predicates[i]);\n      Object.freeze(setProperties[i]);\n      Object.freeze(assertedProperties[i]);\n      Object.freeze(refutedProperties[i]);\n    }\n\n    C._free(sourceAddress);\n\n\n    this[0] = address;\n    this.captureNames = captureNames;\n    this.captureQuantifiers = captureQuantifiers;\n    this.textPredicates = textPredicates;\n    this.predicates = predicates;\n    this.setProperties = setProperties;\n    this.assertedProperties = assertedProperties;\n    this.refutedProperties = refutedProperties;\n    this.exceededMatchLimit = false;\n  }\n\n  /** Delete the query, freeing its resources. */\n  delete(): void {\n    C._ts_query_delete(this[0]);\n    this[0] = 0;\n  }\n\n  /**\n   * Iterate over all of the matches in the order that they were found.\n   *\n   * Each match contains the index of the pattern that matched, and a list of\n   * captures. Because multiple patterns can match the same set of nodes,\n   * one match may contain captures that appear *before* some of the\n   * captures from a previous match.\n   *\n   * @param {Node} node - The node to execute the query on.\n   *\n   * @param {QueryOptions} options - Options for query execution.\n   */\n  matches(\n    node: Node,\n    options: QueryOptions = {}\n  ): QueryMatch[] {\n    const startPosition = options.startPosition ?? ZERO_POINT;\n    const endPosition = options.endPosition ?? ZERO_POINT;\n    const startIndex = options.startIndex ?? 0;\n    const endIndex = options.endIndex ?? 0;\n    const matchLimit = options.matchLimit ?? 0xFFFFFFFF;\n    const maxStartDepth = options.maxStartDepth ?? 0xFFFFFFFF;\n    const timeoutMicros = options.timeoutMicros ?? 0;\n    const progressCallback = options.progressCallback;\n\n    if (typeof matchLimit !== 'number') {\n      throw new Error('Arguments must be numbers');\n    }\n    this.matchLimit = matchLimit;\n\n    if (endIndex !== 0 && startIndex > endIndex) {\n      throw new Error('`startIndex` cannot be greater than `endIndex`');\n    }\n\n    if (endPosition !== ZERO_POINT && (\n      startPosition.row > endPosition.row ||\n      (startPosition.row === endPosition.row && startPosition.column > endPosition.column)\n    )) {\n      throw new Error('`startPosition` cannot be greater than `endPosition`');\n    }\n\n    if (progressCallback) {\n      C.currentQueryProgressCallback = progressCallback;\n    }\n\n    marshalNode(node);\n\n    C._ts_query_matches_wasm(\n      this[0],\n      node.tree[0],\n      startPosition.row,\n      startPosition.column,\n      endPosition.row,\n      endPosition.column,\n      startIndex,\n      endIndex,\n      matchLimit,\n      maxStartDepth,\n      timeoutMicros,\n    );\n\n    const rawCount = C.getValue(TRANSFER_BUFFER, 'i32');\n    const startAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n    const didExceedMatchLimit = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, 'i32');\n    const result = new Array<QueryMatch>(rawCount);\n    this.exceededMatchLimit = Boolean(didExceedMatchLimit);\n\n    let filteredCount = 0;\n    let address = startAddress;\n    for (let i = 0; i < rawCount; i++) {\n      const patternIndex = C.getValue(address, 'i32');\n      address += SIZE_OF_INT;\n      const captureCount = C.getValue(address, 'i32');\n      address += SIZE_OF_INT;\n\n      const captures = new Array<QueryCapture>(captureCount);\n      address = unmarshalCaptures(this, node.tree, address, patternIndex, captures);\n\n      if (this.textPredicates[patternIndex].every((p) => p(captures))) {\n        result[filteredCount] = { pattern: patternIndex, patternIndex, captures };\n        const setProperties = this.setProperties[patternIndex];\n        result[filteredCount].setProperties = setProperties;\n        const assertedProperties = this.assertedProperties[patternIndex];\n        result[filteredCount].assertedProperties = assertedProperties;\n        const refutedProperties = this.refutedProperties[patternIndex];\n        result[filteredCount].refutedProperties = refutedProperties;\n        filteredCount++;\n      }\n    }\n    result.length = filteredCount;\n\n    C._free(startAddress);\n    C.currentQueryProgressCallback = null;\n    return result;\n  }\n\n  /**\n   * Iterate over all of the individual captures in the order that they\n   * appear.\n   *\n   * This is useful if you don't care about which pattern matched, and just\n   * want a single, ordered sequence of captures.\n   *\n   * @param {Node} node - The node to execute the query on.\n   *\n   * @param {QueryOptions} options - Options for query execution.\n   */\n  captures(\n    node: Node,\n    options: QueryOptions = {}\n  ): QueryCapture[] {\n    const startPosition = options.startPosition ?? ZERO_POINT;\n    const endPosition = options.endPosition ?? ZERO_POINT;\n    const startIndex = options.startIndex ?? 0;\n    const endIndex = options.endIndex ?? 0;\n    const matchLimit = options.matchLimit ?? 0xFFFFFFFF;\n    const maxStartDepth = options.maxStartDepth ?? 0xFFFFFFFF;\n    const timeoutMicros = options.timeoutMicros ?? 0;\n    const progressCallback = options.progressCallback;\n\n    if (typeof matchLimit !== 'number') {\n      throw new Error('Arguments must be numbers');\n    }\n    this.matchLimit = matchLimit;\n\n    if (endIndex !== 0 && startIndex > endIndex) {\n      throw new Error('`startIndex` cannot be greater than `endIndex`');\n    }\n\n    if (endPosition !== ZERO_POINT && (\n      startPosition.row > endPosition.row ||\n      (startPosition.row === endPosition.row && startPosition.column > endPosition.column)\n    )) {\n      throw new Error('`startPosition` cannot be greater than `endPosition`');\n    }\n\n    if (progressCallback) {\n      C.currentQueryProgressCallback = progressCallback;\n    }\n\n    marshalNode(node);\n\n    C._ts_query_captures_wasm(\n      this[0],\n      node.tree[0],\n      startPosition.row,\n      startPosition.column,\n      endPosition.row,\n      endPosition.column,\n      startIndex,\n      endIndex,\n      matchLimit,\n      maxStartDepth,\n      timeoutMicros,\n    );\n\n    const count = C.getValue(TRANSFER_BUFFER, 'i32');\n    const startAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n    const didExceedMatchLimit = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, 'i32');\n    const result = new Array<QueryCapture>();\n    this.exceededMatchLimit = Boolean(didExceedMatchLimit);\n\n    const captures = new Array<QueryCapture>();\n    let address = startAddress;\n    for (let i = 0; i < count; i++) {\n      const patternIndex = C.getValue(address, 'i32');\n      address += SIZE_OF_INT;\n      const captureCount = C.getValue(address, 'i32');\n      address += SIZE_OF_INT;\n      const captureIndex = C.getValue(address, 'i32');\n      address += SIZE_OF_INT;\n\n      captures.length = captureCount;\n      address = unmarshalCaptures(this, node.tree, address, patternIndex, captures);\n\n      if (this.textPredicates[patternIndex].every(p => p(captures))) {\n        const capture = captures[captureIndex];\n        const setProperties = this.setProperties[patternIndex];\n        capture.setProperties = setProperties;\n        const assertedProperties = this.assertedProperties[patternIndex];\n        capture.assertedProperties = assertedProperties;\n        const refutedProperties = this.refutedProperties[patternIndex];\n        capture.refutedProperties = refutedProperties;\n        result.push(capture);\n      }\n    }\n\n    C._free(startAddress);\n    C.currentQueryProgressCallback = null;\n    return result;\n  }\n\n  /** Get the predicates for a given pattern. */\n  predicatesForPattern(patternIndex: number): QueryPredicate[] {\n    return this.predicates[patternIndex];\n  }\n\n  /**\n   * Disable a certain capture within a query.\n   *\n   * This prevents the capture from being returned in matches, and also\n   * avoids any resource usage associated with recording the capture.\n   */\n  disableCapture(captureName: string): void {\n    const captureNameLength = C.lengthBytesUTF8(captureName);\n    const captureNameAddress = C._malloc(captureNameLength + 1);\n    C.stringToUTF8(captureName, captureNameAddress, captureNameLength + 1);\n    C._ts_query_disable_capture(this[0], captureNameAddress, captureNameLength);\n    C._free(captureNameAddress);\n  }\n\n  /**\n   * Disable a certain pattern within a query.\n   *\n   * This prevents the pattern from matching, and also avoids any resource\n   * usage associated with the pattern. This throws an error if the pattern\n   * index is out of bounds.\n   */\n  disablePattern(patternIndex: number): void {\n    if (patternIndex >= this.predicates.length) {\n      throw new Error(\n        `Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`\n      );\n    }\n    C._ts_query_disable_pattern(this[0], patternIndex);\n  }\n\n  /**\n   * Check if, on its last execution, this cursor exceeded its maximum number\n   * of in-progress matches.\n   */\n  didExceedMatchLimit(): boolean {\n    return this.exceededMatchLimit;\n  }\n\n  /** Get the byte offset where the given pattern starts in the query's source. */\n  startIndexForPattern(patternIndex: number): number {\n    if (patternIndex >= this.predicates.length) {\n      throw new Error(\n        `Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`\n      );\n    }\n    return C._ts_query_start_byte_for_pattern(this[0], patternIndex);\n  }\n\n  /** Get the byte offset where the given pattern ends in the query's source. */\n  endIndexForPattern(patternIndex: number): number {\n    if (patternIndex >= this.predicates.length) {\n      throw new Error(\n        `Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`\n      );\n    }\n    return C._ts_query_end_byte_for_pattern(this[0], patternIndex);\n  }\n\n  /** Get the number of patterns in the query. */\n  patternCount(): number {\n    return C._ts_query_pattern_count(this[0]);\n  }\n\n  /** Get the index for a given capture name. */\n  captureIndexForName(captureName: string): number {\n    return this.captureNames.indexOf(captureName);\n  }\n\n  /** Check if a given pattern within a query has a single root node. */\n  isPatternRooted(patternIndex: number): boolean {\n    return C._ts_query_is_pattern_rooted(this[0], patternIndex) === 1;\n  }\n\n  /** Check if a given pattern within a query has a single root node. */\n  isPatternNonLocal(patternIndex: number): boolean {\n    return C._ts_query_is_pattern_non_local(this[0], patternIndex) === 1;\n  }\n\n  /**\n   * Check if a given step in a query is 'definite'.\n   *\n   * A query step is 'definite' if its parent pattern will be guaranteed to\n   * match successfully once it reaches the step.\n   */\n  isPatternGuaranteedAtStep(byteIndex: number): boolean {\n    return C._ts_query_is_pattern_guaranteed_at_step(this[0], byteIndex) === 1;\n  }\n}\n","import { C, INTERNAL, Internal, assertInternal, SIZE_OF_INT, SIZE_OF_SHORT } from './constants';\nimport { LookaheadIterator } from './lookahead_iterator';\nimport { unmarshalLanguageMetadata } from './marshal';\nimport { TRANSFER_BUFFER } from './parser';\nimport { Query } from './query';\n\nconst LANGUAGE_FUNCTION_REGEX = /^tree_sitter_\\w+$/;\n\nexport interface LanguageMetadata {\n  readonly major_version: number;\n  readonly minor_version: number;\n  readonly patch_version: number;\n}\n\n/**\n * An opaque object that defines how to parse a particular language.\n * The code for each `Language` is generated by the Tree-sitter CLI.\n */\nexport class Language {\n  /** @internal */\n  private [0] = 0; // Internal handle for WASM\n\n  /**\n   * A list of all node types in the language. The index of each type in this\n   * array is its node type id.\n   */\n  types: string[];\n\n  /**\n   * A list of all field names in the language. The index of each field name in\n   * this array is its field id.\n   */\n  fields: (string | null)[];\n\n  /** @internal */\n  constructor(internal: Internal, address: number) {\n    assertInternal(internal);\n    this[0] = address;\n    this.types = new Array<string>(C._ts_language_symbol_count(this[0]));\n    for (let i = 0, n = this.types.length; i < n; i++) {\n      if (C._ts_language_symbol_type(this[0], i) < 2) {\n        this.types[i] = C.UTF8ToString(C._ts_language_symbol_name(this[0], i));\n      }\n    }\n    this.fields = new Array<string>(C._ts_language_field_count(this[0]) + 1);\n    for (let i = 0, n = this.fields.length; i < n; i++) {\n      const fieldName = C._ts_language_field_name_for_id(this[0], i);\n      if (fieldName !== 0) {\n        this.fields[i] = C.UTF8ToString(fieldName);\n      } else {\n        this.fields[i] = null;\n      }\n    }\n  }\n\n\n  /**\n   * Gets the name of the language.\n   */\n  get name(): string | null {\n    const ptr = C._ts_language_name(this[0]);\n    if (ptr === 0) return null;\n    return C.UTF8ToString(ptr);\n  }\n\n  /**\n   * @deprecated since version 0.25.0, use {@link Language#abiVersion} instead\n   * Gets the version of the language.\n   */\n  get version(): number {\n    return C._ts_language_version(this[0]);\n  }\n\n  /**\n   * Gets the ABI version of the language.\n   */\n  get abiVersion(): number {\n    return C._ts_language_abi_version(this[0]);\n  }\n\n  /**\n  * Get the metadata for this language. This information is generated by the\n  * CLI, and relies on the language author providing the correct metadata in\n  * the language's `tree-sitter.json` file.\n  */\n  get metadata(): LanguageMetadata | null {\n    C._ts_language_metadata(this[0]);\n    const length = C.getValue(TRANSFER_BUFFER, 'i32');\n    const address = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n    if (length === 0) return null;\n    return unmarshalLanguageMetadata(address);\n  }\n\n  /**\n   * Gets the number of fields in the language.\n   */\n  get fieldCount(): number {\n    return this.fields.length - 1;\n  }\n\n  /**\n   * Gets the number of states in the language.\n   */\n  get stateCount(): number {\n    return C._ts_language_state_count(this[0]);\n  }\n\n  /**\n   * Get the field id for a field name.\n   */\n  fieldIdForName(fieldName: string): number | null {\n    const result = this.fields.indexOf(fieldName);\n    return result !== -1 ? result : null;\n  }\n\n  /**\n   * Get the field name for a field id.\n   */\n  fieldNameForId(fieldId: number): string | null {\n    return this.fields[fieldId] ?? null;\n  }\n\n  /**\n   * Get the node type id for a node type name.\n   */\n  idForNodeType(type: string, named: boolean): number | null {\n    const typeLength = C.lengthBytesUTF8(type);\n    const typeAddress = C._malloc(typeLength + 1);\n    C.stringToUTF8(type, typeAddress, typeLength + 1);\n    const result = C._ts_language_symbol_for_name(this[0], typeAddress, typeLength, named ? 1 : 0);\n    C._free(typeAddress);\n    return result || null;\n  }\n\n  /**\n   * Gets the number of node types in the language.\n   */\n  get nodeTypeCount(): number {\n    return C._ts_language_symbol_count(this[0]);\n  }\n\n  /**\n   * Get the node type name for a node type id.\n   */\n  nodeTypeForId(typeId: number): string | null {\n    const name = C._ts_language_symbol_name(this[0], typeId);\n    return name ? C.UTF8ToString(name) : null;\n  }\n\n  /**\n   * Check if a node type is named.\n   *\n   * @see {@link https://tree-sitter.github.io/tree-sitter/using-parsers/2-basic-parsing.html#named-vs-anonymous-nodes}\n   */\n  nodeTypeIsNamed(typeId: number): boolean {\n    return C._ts_language_type_is_named_wasm(this[0], typeId) ? true : false;\n  }\n\n  /**\n   * Check if a node type is visible.\n   */\n  nodeTypeIsVisible(typeId: number): boolean {\n    return C._ts_language_type_is_visible_wasm(this[0], typeId) ? true : false;\n  }\n\n  /**\n   * Get the supertypes ids of this language.\n   *\n   * @see {@link https://tree-sitter.github.io/tree-sitter/using-parsers/6-static-node-types.html?highlight=supertype#supertype-nodes}\n   */\n  get supertypes(): number[] {\n    C._ts_language_supertypes_wasm(this[0]);\n    const count = C.getValue(TRANSFER_BUFFER, 'i32');\n    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n    const result = new Array<number>(count);\n\n    if (count > 0) {\n      let address = buffer;\n      for (let i = 0; i < count; i++) {\n        result[i] = C.getValue(address, 'i16');\n        address += SIZE_OF_SHORT;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Get the subtype ids for a given supertype node id.\n   */\n  subtypes(supertype: number): number[] {\n    C._ts_language_subtypes_wasm(this[0], supertype);\n    const count = C.getValue(TRANSFER_BUFFER, 'i32');\n    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n    const result = new Array<number>(count);\n\n    if (count > 0) {\n      let address = buffer;\n      for (let i = 0; i < count; i++) {\n        result[i] = C.getValue(address, 'i16');\n        address += SIZE_OF_SHORT;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Get the next state id for a given state id and node type id.\n   */\n  nextState(stateId: number, typeId: number): number {\n    return C._ts_language_next_state(this[0], stateId, typeId);\n  }\n\n  /**\n   * Create a new lookahead iterator for this language and parse state.\n   *\n   * This returns `null` if state is invalid for this language.\n   *\n   * Iterating {@link LookaheadIterator} will yield valid symbols in the given\n   * parse state. Newly created lookahead iterators will return the `ERROR`\n   * symbol from {@link LookaheadIterator#currentType}.\n   *\n   * Lookahead iterators can be useful for generating suggestions and improving\n   * syntax error diagnostics. To get symbols valid in an `ERROR` node, use the\n   * lookahead iterator on its first leaf node state. For `MISSING` nodes, a\n   * lookahead iterator created on the previous non-extra leaf node may be\n   * appropriate.\n   */\n  lookaheadIterator(stateId: number): LookaheadIterator | null {\n    const address = C._ts_lookahead_iterator_new(this[0], stateId);\n    if (address) return new LookaheadIterator(INTERNAL, address, this);\n    return null;\n  }\n\n  /**\n   * @deprecated since version 0.25.0, call `new` on a {@link Query} instead\n   *\n   * Create a new query from a string containing one or more S-expression\n   * patterns.\n   *\n   * The query is associated with a particular language, and can only be run\n   * on syntax nodes parsed with that language. References to Queries can be\n   * shared between multiple threads.\n   *\n   * @link {@see https://tree-sitter.github.io/tree-sitter/using-parsers/queries}\n   */\n  query(source: string): Query {\n    console.warn('Language.query is deprecated. Use new Query(language, source) instead.');\n    return new Query(this, source);\n  }\n\n  /**\n   * Load a language from a WebAssembly module.\n   * The module can be provided as a path to a file or as a buffer.\n   */\n  static async load(input: string | Uint8Array): Promise<Language> {\n    let bytes: Promise<Uint8Array>;\n    if (input instanceof Uint8Array) {\n      bytes = Promise.resolve(input);\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (globalThis.process?.versions.node) {\n        const fs: typeof import('fs/promises') = await import('fs/promises');\n        bytes = fs.readFile(input);\n      } else {\n        bytes = fetch(input)\n          .then((response) => response.arrayBuffer()\n            .then((buffer) => {\n              if (response.ok) {\n                return new Uint8Array(buffer);\n              } else {\n                const body = new TextDecoder('utf-8').decode(buffer);\n                throw new Error(`Language.load failed with status ${response.status}.\\n\\n${body}`);\n              }\n            }));\n      }\n    }\n\n    const mod = await C.loadWebAssemblyModule(await bytes, { loadAsync: true });\n    const symbolNames = Object.keys(mod);\n    const functionName = symbolNames.find((key) => LANGUAGE_FUNCTION_REGEX.test(key) &&\n      !key.includes('external_scanner_'));\n    if (!functionName) {\n        console.log(`Couldn't find language function in WASM file. Symbols:\\n${JSON.stringify(symbolNames, null, 2)}`);\n        throw new Error('Language.load failed: no language function found in WASM file');\n    }\n    const languageAddress = mod[functionName]();\n    return new Language(INTERNAL, languageAddress);\n  }\n}\n","var Module = (() => {\n  var _scriptName = import.meta.url;\n  \n  return (\nasync function(moduleArg = {}) {\n  var moduleRtn;\n\n// include: shell.js\n// The Module object: Our interface to the outside world. We import\n// and export values on it. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(moduleArg) => Promise<Module>\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to check if Module already exists (e.g. case 3 above).\n// Substitution will be replaced with actual code on later stage of the build,\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module = moduleArg;\n\n// Set up the promise that indicates the Module is initialized\nvar readyPromiseResolve, readyPromiseReject;\n\nvar readyPromise = new Promise((resolve, reject) => {\n  readyPromiseResolve = resolve;\n  readyPromiseReject = reject;\n});\n\n// Determine the runtime environment we are in. You can customize this by\n// setting the ENVIRONMENT setting at compile time (see settings.js).\n// Attempt to auto-detect the environment\nvar ENVIRONMENT_IS_WEB = typeof window == \"object\";\n\nvar ENVIRONMENT_IS_WORKER = typeof WorkerGlobalScope != \"undefined\";\n\n// N.b. Electron.js environment is simultaneously a NODE-environment, but\n// also a web environment.\nvar ENVIRONMENT_IS_NODE = typeof process == \"object\" && typeof process.versions == \"object\" && typeof process.versions.node == \"string\" && process.type != \"renderer\";\n\nvar ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\nif (ENVIRONMENT_IS_NODE) {\n  // When building an ES module `require` is not normally available.\n  // We need to use `createRequire()` to construct the require()` function.\n  const {createRequire} = await import(\"module\");\n  /** @suppress{duplicate} */ var require = createRequire(import.meta.url);\n}\n\n// --pre-jses are emitted after the Module integration code, so that they can\n// refer to Module (if they choose; they can also define Module)\n// include: lib/binding_web/lib/prefix.js\nModule.currentQueryProgressCallback = null;\n\nModule.currentProgressCallback = null;\n\nModule.currentLogCallback = null;\n\nModule.currentParseCallback = null;\n\n// end include: lib/binding_web/lib/prefix.js\n// Sometimes an existing Module object exists with properties\n// meant to overwrite the default module functionality. Here\n// we collect those properties and reapply _after_ we configure\n// the current environment's defaults to avoid having to be so\n// defensive during initialization.\nvar moduleOverrides = Object.assign({}, Module);\n\nvar arguments_ = [];\n\nvar thisProgram = \"./this.program\";\n\nvar quit_ = (status, toThrow) => {\n  throw toThrow;\n};\n\n// `/` should be present at the end if `scriptDirectory` is not empty\nvar scriptDirectory = \"\";\n\nfunction locateFile(path) {\n  if (Module[\"locateFile\"]) {\n    return Module[\"locateFile\"](path, scriptDirectory);\n  }\n  return scriptDirectory + path;\n}\n\n// Hooks that are implemented differently in different runtime environments.\nvar readAsync, readBinary;\n\nif (ENVIRONMENT_IS_NODE) {\n  // These modules will usually be used on Node.js. Load them eagerly to avoid\n  // the complexity of lazy-loading.\n  var fs = require(\"fs\");\n  var nodePath = require(\"path\");\n  // EXPORT_ES6 + ENVIRONMENT_IS_NODE always requires use of import.meta.url,\n  // since there's no way getting the current absolute path of the module when\n  // support for that is not available.\n  if (!import.meta.url.startsWith(\"data:\")) {\n    scriptDirectory = nodePath.dirname(require(\"url\").fileURLToPath(import.meta.url)) + \"/\";\n  }\n  // include: node_shell_read.js\n  readBinary = filename => {\n    // We need to re-wrap `file://` strings to URLs.\n    filename = isFileURI(filename) ? new URL(filename) : filename;\n    var ret = fs.readFileSync(filename);\n    return ret;\n  };\n  readAsync = async (filename, binary = true) => {\n    // See the comment in the `readBinary` function.\n    filename = isFileURI(filename) ? new URL(filename) : filename;\n    var ret = fs.readFileSync(filename, binary ? undefined : \"utf8\");\n    return ret;\n  };\n  // end include: node_shell_read.js\n  if (!Module[\"thisProgram\"] && process.argv.length > 1) {\n    thisProgram = process.argv[1].replace(/\\\\/g, \"/\");\n  }\n  arguments_ = process.argv.slice(2);\n  // MODULARIZE will export the module in the proper place outside, we don't need to export here\n  quit_ = (status, toThrow) => {\n    process.exitCode = status;\n    throw toThrow;\n  };\n} else // Note that this includes Node.js workers when relevant (pthreads is enabled).\n// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n// ENVIRONMENT_IS_NODE.\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  if (ENVIRONMENT_IS_WORKER) {\n    // Check worker, not web, since window could be polyfilled\n    scriptDirectory = self.location.href;\n  } else if (typeof document != \"undefined\" && document.currentScript) {\n    // web\n    scriptDirectory = document.currentScript.src;\n  }\n  // When MODULARIZE, this JS may be executed later, after document.currentScript\n  // is gone, so we saved it, and we use it here instead of any other info.\n  if (_scriptName) {\n    scriptDirectory = _scriptName;\n  }\n  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n  // otherwise, slice off the final part of the url to find the script directory.\n  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n  // and scriptDirectory will correctly be replaced with an empty string.\n  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),\n  // they are removed because they could contain a slash.\n  if (scriptDirectory.startsWith(\"blob:\")) {\n    scriptDirectory = \"\";\n  } else {\n    scriptDirectory = scriptDirectory.slice(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\n  }\n  {\n    // include: web_or_worker_shell_read.js\n    if (ENVIRONMENT_IS_WORKER) {\n      readBinary = url => {\n        var xhr = new XMLHttpRequest;\n        xhr.open(\"GET\", url, false);\n        xhr.responseType = \"arraybuffer\";\n        xhr.send(null);\n        return new Uint8Array(/** @type{!ArrayBuffer} */ (xhr.response));\n      };\n    }\n    readAsync = async url => {\n      // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.\n      // See https://github.com/github/fetch/pull/92#issuecomment-140665932\n      // Cordova or Electron apps are typically loaded from a file:// url.\n      // So use XHR on webview if URL is a file URL.\n      if (isFileURI(url)) {\n        return new Promise((resolve, reject) => {\n          var xhr = new XMLHttpRequest;\n          xhr.open(\"GET\", url, true);\n          xhr.responseType = \"arraybuffer\";\n          xhr.onload = () => {\n            if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {\n              // file URLs can return 0\n              resolve(xhr.response);\n              return;\n            }\n            reject(xhr.status);\n          };\n          xhr.onerror = reject;\n          xhr.send(null);\n        });\n      }\n      var response = await fetch(url, {\n        credentials: \"same-origin\"\n      });\n      if (response.ok) {\n        return response.arrayBuffer();\n      }\n      throw new Error(response.status + \" : \" + response.url);\n    };\n  }\n} else {}\n\nvar out = Module[\"print\"] || console.log.bind(console);\n\nvar err = Module[\"printErr\"] || console.error.bind(console);\n\n// Merge back in the overrides\nObject.assign(Module, moduleOverrides);\n\n// Free the object hierarchy contained in the overrides, this lets the GC\n// reclaim data used.\nmoduleOverrides = null;\n\n// Emit code to handle expected values on the Module object. This applies Module.x\n// to the proper local x. This has two benefits: first, we only emit it if it is\n// expected to arrive, and second, by using a local everywhere else that can be\n// minified.\nif (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n\nif (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n\n// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n// end include: shell.js\n// include: preamble.js\n// === Preamble library stuff ===\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\nvar dynamicLibraries = Module[\"dynamicLibraries\"] || [];\n\nvar wasmBinary = Module[\"wasmBinary\"];\n\n// Wasm globals\nvar wasmMemory;\n\n//========================================\n// Runtime essentials\n//========================================\n// whether we are quitting the application. no code should run after this.\n// set in exit() and abort()\nvar ABORT = false;\n\n// set by exit() and abort().  Passed to 'onExit' handler.\n// NOTE: This is also used as the process return code code in shell environments\n// but only when noExitRuntime is false.\nvar EXITSTATUS;\n\n// In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we\n// don't define it at all in release modes.  This matches the behaviour of\n// MINIMAL_RUNTIME.\n// TODO(sbc): Make this the default even without STRICT enabled.\n/** @type {function(*, string=)} */ function assert(condition, text) {\n  if (!condition) {\n    // This build was created without ASSERTIONS defined.  `assert()` should not\n    // ever be called in this configuration but in case there are callers in\n    // the wild leave this simple abort() implementation here for now.\n    abort(text);\n  }\n}\n\n// Memory management\nvar HEAP, /** @type {!Int8Array} */ HEAP8, /** @type {!Uint8Array} */ HEAPU8, /** @type {!Int16Array} */ HEAP16, /** @type {!Uint16Array} */ HEAPU16, /** @type {!Int32Array} */ HEAP32, /** @type {!Uint32Array} */ HEAPU32, /** @type {!Float32Array} */ HEAPF32, /* BigInt64Array type is not correctly defined in closure\n/** not-@type {!BigInt64Array} */ HEAP64, /* BigUint64Array type is not correctly defined in closure\n/** not-t@type {!BigUint64Array} */ HEAPU64, /** @type {!Float64Array} */ HEAPF64;\n\nvar HEAP_DATA_VIEW;\n\nvar runtimeInitialized = false;\n\n/**\n * Indicates whether filename is delivered via file protocol (as opposed to http/https)\n * @noinline\n */ var isFileURI = filename => filename.startsWith(\"file://\");\n\n// include: runtime_shared.js\n// include: runtime_stack_check.js\n// end include: runtime_stack_check.js\n// include: runtime_exceptions.js\n// end include: runtime_exceptions.js\n// include: runtime_debug.js\n// end include: runtime_debug.js\n// include: memoryprofiler.js\n// end include: memoryprofiler.js\nfunction updateMemoryViews() {\n  var b = wasmMemory.buffer;\n  Module[\"HEAP_DATA_VIEW\"] = HEAP_DATA_VIEW = new DataView(b);\n  Module[\"HEAP8\"] = HEAP8 = new Int8Array(b);\n  Module[\"HEAP16\"] = HEAP16 = new Int16Array(b);\n  Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(b);\n  Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(b);\n  Module[\"HEAP32\"] = HEAP32 = new Int32Array(b);\n  Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(b);\n  Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(b);\n  Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(b);\n  Module[\"HEAP64\"] = HEAP64 = new BigInt64Array(b);\n  Module[\"HEAPU64\"] = HEAPU64 = new BigUint64Array(b);\n}\n\n// end include: runtime_shared.js\n// In non-standalone/normal mode, we create the memory here.\n// include: runtime_init_memory.js\n// Create the wasm memory. (Note: this only applies if IMPORTED_MEMORY is defined)\n// check for full engine support (use string 'subarray' to avoid closure compiler confusion)\nif (Module[\"wasmMemory\"]) {\n  wasmMemory = Module[\"wasmMemory\"];\n} else {\n  var INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 33554432;\n  /** @suppress {checkTypes} */ wasmMemory = new WebAssembly.Memory({\n    \"initial\": INITIAL_MEMORY / 65536,\n    // In theory we should not need to emit the maximum if we want \"unlimited\"\n    // or 4GB of memory, but VMs error on that atm, see\n    // https://github.com/emscripten-core/emscripten/issues/14130\n    // And in the pthreads case we definitely need to emit a maximum. So\n    // always emit one.\n    \"maximum\": 32768\n  });\n}\n\nupdateMemoryViews();\n\n// end include: runtime_init_memory.js\nvar __RELOC_FUNCS__ = [];\n\nfunction preRun() {\n  if (Module[\"preRun\"]) {\n    if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [ Module[\"preRun\"] ];\n    while (Module[\"preRun\"].length) {\n      addOnPreRun(Module[\"preRun\"].shift());\n    }\n  }\n  callRuntimeCallbacks(onPreRuns);\n}\n\nfunction initRuntime() {\n  runtimeInitialized = true;\n  callRuntimeCallbacks(__RELOC_FUNCS__);\n  wasmExports[\"__wasm_call_ctors\"]();\n  callRuntimeCallbacks(onPostCtors);\n}\n\nfunction preMain() {}\n\nfunction postRun() {\n  if (Module[\"postRun\"]) {\n    if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [ Module[\"postRun\"] ];\n    while (Module[\"postRun\"].length) {\n      addOnPostRun(Module[\"postRun\"].shift());\n    }\n  }\n  callRuntimeCallbacks(onPostRuns);\n}\n\n// A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// Module.preRun (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\nvar runDependencies = 0;\n\nvar dependenciesFulfilled = null;\n\n// overridden to take different actions when all run dependencies are fulfilled\nfunction getUniqueRunDependency(id) {\n  return id;\n}\n\nfunction addRunDependency(id) {\n  runDependencies++;\n  Module[\"monitorRunDependencies\"]?.(runDependencies);\n}\n\nfunction removeRunDependency(id) {\n  runDependencies--;\n  Module[\"monitorRunDependencies\"]?.(runDependencies);\n  if (runDependencies == 0) {\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback();\n    }\n  }\n}\n\n/** @param {string|number=} what */ function abort(what) {\n  Module[\"onAbort\"]?.(what);\n  what = \"Aborted(\" + what + \")\";\n  // TODO(sbc): Should we remove printing and leave it up to whoever\n  // catches the exception?\n  err(what);\n  ABORT = true;\n  what += \". Build with -sASSERTIONS for more info.\";\n  // Use a wasm runtime error, because a JS error might be seen as a foreign\n  // exception, which means we'd run destructors on it. We need the error to\n  // simply make the program stop.\n  // FIXME This approach does not work in Wasm EH because it currently does not assume\n  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\n  // a trap or not based on a hidden field within the object. So at the moment\n  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\n  // allows this in the wasm spec.\n  // Suppress closure compiler warning here. Closure compiler's builtin extern\n  // definition for WebAssembly.RuntimeError claims it takes no arguments even\n  // though it can.\n  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\n  /** @suppress {checkTypes} */ var e = new WebAssembly.RuntimeError(what);\n  readyPromiseReject(e);\n  // Throw the error whether or not MODULARIZE is set because abort is used\n  // in code paths apart from instantiation where an exception is expected\n  // to be thrown when abort is called.\n  throw e;\n}\n\nvar wasmBinaryFile;\n\nfunction findWasmBinary() {\n  if (Module[\"locateFile\"]) {\n    return locateFile(\"tree-sitter.wasm\");\n  }\n  // Use bundler-friendly `new URL(..., import.meta.url)` pattern; works in browsers too.\n  return new URL(\"tree-sitter.wasm\", import.meta.url).href;\n}\n\nfunction getBinarySync(file) {\n  if (file == wasmBinaryFile && wasmBinary) {\n    return new Uint8Array(wasmBinary);\n  }\n  if (readBinary) {\n    return readBinary(file);\n  }\n  throw \"both async and sync fetching of the wasm failed\";\n}\n\nasync function getWasmBinary(binaryFile) {\n  // If we don't have the binary yet, load it asynchronously using readAsync.\n  if (!wasmBinary) {\n    // Fetch the binary using readAsync\n    try {\n      var response = await readAsync(binaryFile);\n      return new Uint8Array(response);\n    } catch {}\n  }\n  // Otherwise, getBinarySync should be able to get it synchronously\n  return getBinarySync(binaryFile);\n}\n\nasync function instantiateArrayBuffer(binaryFile, imports) {\n  try {\n    var binary = await getWasmBinary(binaryFile);\n    var instance = await WebAssembly.instantiate(binary, imports);\n    return instance;\n  } catch (reason) {\n    err(`failed to asynchronously prepare wasm: ${reason}`);\n    abort(reason);\n  }\n}\n\nasync function instantiateAsync(binary, binaryFile, imports) {\n  if (!binary && typeof WebAssembly.instantiateStreaming == \"function\" && !isFileURI(binaryFile) && !ENVIRONMENT_IS_NODE) {\n    try {\n      var response = fetch(binaryFile, {\n        credentials: \"same-origin\"\n      });\n      var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);\n      return instantiationResult;\n    } catch (reason) {\n      // We expect the most common failure cause to be a bad MIME type for the binary,\n      // in which case falling back to ArrayBuffer instantiation should work.\n      err(`wasm streaming compile failed: ${reason}`);\n      err(\"falling back to ArrayBuffer instantiation\");\n    }\n  }\n  return instantiateArrayBuffer(binaryFile, imports);\n}\n\nfunction getWasmImports() {\n  // prepare imports\n  return {\n    \"env\": wasmImports,\n    \"wasi_snapshot_preview1\": wasmImports,\n    \"GOT.mem\": new Proxy(wasmImports, GOTHandler),\n    \"GOT.func\": new Proxy(wasmImports, GOTHandler)\n  };\n}\n\n// Create the wasm instance.\n// Receives the wasm imports, returns the exports.\nasync function createWasm() {\n  // Load the wasm module and create an instance of using native support in the JS engine.\n  // handle a generated wasm instance, receiving its exports and\n  // performing other necessary setup\n  /** @param {WebAssembly.Module=} module*/ function receiveInstance(instance, module) {\n    wasmExports = instance.exports;\n    wasmExports = relocateExports(wasmExports, 1024);\n    var metadata = getDylinkMetadata(module);\n    if (metadata.neededDynlibs) {\n      dynamicLibraries = metadata.neededDynlibs.concat(dynamicLibraries);\n    }\n    mergeLibSymbols(wasmExports, \"main\");\n    LDSO.init();\n    loadDylibs();\n    __RELOC_FUNCS__.push(wasmExports[\"__wasm_apply_data_relocs\"]);\n    removeRunDependency(\"wasm-instantiate\");\n    return wasmExports;\n  }\n  // wait for the pthread pool (if any)\n  addRunDependency(\"wasm-instantiate\");\n  // Prefer streaming instantiation if available.\n  function receiveInstantiationResult(result) {\n    // 'result' is a ResultObject object which has both the module and instance.\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n    return receiveInstance(result[\"instance\"], result[\"module\"]);\n  }\n  var info = getWasmImports();\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n  // to manually instantiate the Wasm module themselves. This allows pages to\n  // run the instantiation parallel to any other async startup actions they are\n  // performing.\n  // Also pthreads and wasm workers initialize the wasm instance through this\n  // path.\n  if (Module[\"instantiateWasm\"]) {\n    return new Promise((resolve, reject) => {\n      Module[\"instantiateWasm\"](info, (mod, inst) => {\n        receiveInstance(mod, inst);\n        resolve(mod.exports);\n      });\n    });\n  }\n  wasmBinaryFile ??= findWasmBinary();\n  try {\n    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);\n    var exports = receiveInstantiationResult(result);\n    return exports;\n  } catch (e) {\n    // If instantiation fails, reject the module ready promise.\n    readyPromiseReject(e);\n    return Promise.reject(e);\n  }\n}\n\n// === Body ===\nvar ASM_CONSTS = {};\n\n// end include: preamble.js\nclass ExitStatus {\n  name=\"ExitStatus\";\n  constructor(status) {\n    this.message = `Program terminated with exit(${status})`;\n    this.status = status;\n  }\n}\n\nvar GOT = {};\n\nvar currentModuleWeakSymbols = new Set([]);\n\nvar GOTHandler = {\n  get(obj, symName) {\n    var rtn = GOT[symName];\n    if (!rtn) {\n      rtn = GOT[symName] = new WebAssembly.Global({\n        \"value\": \"i32\",\n        \"mutable\": true\n      });\n    }\n    if (!currentModuleWeakSymbols.has(symName)) {\n      // Any non-weak reference to a symbol marks it as `required`, which\n      // enabled `reportUndefinedSymbols` to report undefined symbol errors\n      // correctly.\n      rtn.required = true;\n    }\n    return rtn;\n  }\n};\n\nvar LE_HEAP_LOAD_F32 = byteOffset => HEAP_DATA_VIEW.getFloat32(byteOffset, true);\n\nvar LE_HEAP_LOAD_F64 = byteOffset => HEAP_DATA_VIEW.getFloat64(byteOffset, true);\n\nvar LE_HEAP_LOAD_I16 = byteOffset => HEAP_DATA_VIEW.getInt16(byteOffset, true);\n\nvar LE_HEAP_LOAD_I32 = byteOffset => HEAP_DATA_VIEW.getInt32(byteOffset, true);\n\nvar LE_HEAP_LOAD_U16 = byteOffset => HEAP_DATA_VIEW.getUint16(byteOffset, true);\n\nvar LE_HEAP_LOAD_U32 = byteOffset => HEAP_DATA_VIEW.getUint32(byteOffset, true);\n\nvar LE_HEAP_STORE_F32 = (byteOffset, value) => HEAP_DATA_VIEW.setFloat32(byteOffset, value, true);\n\nvar LE_HEAP_STORE_F64 = (byteOffset, value) => HEAP_DATA_VIEW.setFloat64(byteOffset, value, true);\n\nvar LE_HEAP_STORE_I16 = (byteOffset, value) => HEAP_DATA_VIEW.setInt16(byteOffset, value, true);\n\nvar LE_HEAP_STORE_I32 = (byteOffset, value) => HEAP_DATA_VIEW.setInt32(byteOffset, value, true);\n\nvar LE_HEAP_STORE_U16 = (byteOffset, value) => HEAP_DATA_VIEW.setUint16(byteOffset, value, true);\n\nvar LE_HEAP_STORE_U32 = (byteOffset, value) => HEAP_DATA_VIEW.setUint32(byteOffset, value, true);\n\nvar callRuntimeCallbacks = callbacks => {\n  while (callbacks.length > 0) {\n    // Pass the module as the first argument.\n    callbacks.shift()(Module);\n  }\n};\n\nvar onPostRuns = [];\n\nvar addOnPostRun = cb => onPostRuns.unshift(cb);\n\nvar onPreRuns = [];\n\nvar addOnPreRun = cb => onPreRuns.unshift(cb);\n\nvar UTF8Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder : undefined;\n\n/**\n     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\n     * array that contains uint8 values, returns a copy of that string as a\n     * Javascript String object.\n     * heapOrArray is either a regular array, or a JavaScript typed array view.\n     * @param {number=} idx\n     * @param {number=} maxBytesToRead\n     * @return {string}\n     */ var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {\n  var endIdx = idx + maxBytesToRead;\n  var endPtr = idx;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on\n  // null terminator by itself.  Also, use the length info to avoid running tiny\n  // strings through TextDecoder, since .subarray() allocates garbage.\n  // (As a tiny code save trick, compare endPtr against endIdx using a negation,\n  // so that undefined/NaN means Infinity)\n  while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n  }\n  var str = \"\";\n  // If building with TextDecoder, we have already computed the string length\n  // above, so test loop end condition against that\n  while (idx < endPtr) {\n    // For UTF8 byte structure, see:\n    // http://en.wikipedia.org/wiki/UTF-8#Description\n    // https://www.ietf.org/rfc/rfc2279.txt\n    // https://tools.ietf.org/html/rfc3629\n    var u0 = heapOrArray[idx++];\n    if (!(u0 & 128)) {\n      str += String.fromCharCode(u0);\n      continue;\n    }\n    var u1 = heapOrArray[idx++] & 63;\n    if ((u0 & 224) == 192) {\n      str += String.fromCharCode(((u0 & 31) << 6) | u1);\n      continue;\n    }\n    var u2 = heapOrArray[idx++] & 63;\n    if ((u0 & 240) == 224) {\n      u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n    } else {\n      u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\n    }\n    if (u0 < 65536) {\n      str += String.fromCharCode(u0);\n    } else {\n      var ch = u0 - 65536;\n      str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\n    }\n  }\n  return str;\n};\n\nvar getDylinkMetadata = binary => {\n  var offset = 0;\n  var end = 0;\n  function getU8() {\n    return binary[offset++];\n  }\n  function getLEB() {\n    var ret = 0;\n    var mul = 1;\n    while (1) {\n      var byte = binary[offset++];\n      ret += ((byte & 127) * mul);\n      mul *= 128;\n      if (!(byte & 128)) break;\n    }\n    return ret;\n  }\n  function getString() {\n    var len = getLEB();\n    offset += len;\n    return UTF8ArrayToString(binary, offset - len, len);\n  }\n  /** @param {string=} message */ function failIf(condition, message) {\n    if (condition) throw new Error(message);\n  }\n  var name = \"dylink.0\";\n  if (binary instanceof WebAssembly.Module) {\n    var dylinkSection = WebAssembly.Module.customSections(binary, name);\n    if (dylinkSection.length === 0) {\n      name = \"dylink\";\n      dylinkSection = WebAssembly.Module.customSections(binary, name);\n    }\n    failIf(dylinkSection.length === 0, \"need dylink section\");\n    binary = new Uint8Array(dylinkSection[0]);\n    end = binary.length;\n  } else {\n    var int32View = new Uint32Array(new Uint8Array(binary.subarray(0, 24)).buffer);\n    var magicNumberFound = int32View[0] == 1836278016 || int32View[0] == 6386541;\n    failIf(!magicNumberFound, \"need to see wasm magic number\");\n    // \\0asm\n    // we should see the dylink custom section right after the magic number and wasm version\n    failIf(binary[8] !== 0, \"need the dylink section to be first\");\n    offset = 9;\n    var section_size = getLEB();\n    //section size\n    end = offset + section_size;\n    name = getString();\n  }\n  var customSection = {\n    neededDynlibs: [],\n    tlsExports: new Set,\n    weakImports: new Set\n  };\n  if (name == \"dylink\") {\n    customSection.memorySize = getLEB();\n    customSection.memoryAlign = getLEB();\n    customSection.tableSize = getLEB();\n    customSection.tableAlign = getLEB();\n    // shared libraries this module needs. We need to load them first, so that\n    // current module could resolve its imports. (see tools/shared.py\n    // WebAssembly.make_shared_library() for \"dylink\" section extension format)\n    var neededDynlibsCount = getLEB();\n    for (var i = 0; i < neededDynlibsCount; ++i) {\n      var libname = getString();\n      customSection.neededDynlibs.push(libname);\n    }\n  } else {\n    failIf(name !== \"dylink.0\");\n    var WASM_DYLINK_MEM_INFO = 1;\n    var WASM_DYLINK_NEEDED = 2;\n    var WASM_DYLINK_EXPORT_INFO = 3;\n    var WASM_DYLINK_IMPORT_INFO = 4;\n    var WASM_SYMBOL_TLS = 256;\n    var WASM_SYMBOL_BINDING_MASK = 3;\n    var WASM_SYMBOL_BINDING_WEAK = 1;\n    while (offset < end) {\n      var subsectionType = getU8();\n      var subsectionSize = getLEB();\n      if (subsectionType === WASM_DYLINK_MEM_INFO) {\n        customSection.memorySize = getLEB();\n        customSection.memoryAlign = getLEB();\n        customSection.tableSize = getLEB();\n        customSection.tableAlign = getLEB();\n      } else if (subsectionType === WASM_DYLINK_NEEDED) {\n        var neededDynlibsCount = getLEB();\n        for (var i = 0; i < neededDynlibsCount; ++i) {\n          libname = getString();\n          customSection.neededDynlibs.push(libname);\n        }\n      } else if (subsectionType === WASM_DYLINK_EXPORT_INFO) {\n        var count = getLEB();\n        while (count--) {\n          var symname = getString();\n          var flags = getLEB();\n          if (flags & WASM_SYMBOL_TLS) {\n            customSection.tlsExports.add(symname);\n          }\n        }\n      } else if (subsectionType === WASM_DYLINK_IMPORT_INFO) {\n        var count = getLEB();\n        while (count--) {\n          var modname = getString();\n          var symname = getString();\n          var flags = getLEB();\n          if ((flags & WASM_SYMBOL_BINDING_MASK) == WASM_SYMBOL_BINDING_WEAK) {\n            customSection.weakImports.add(symname);\n          }\n        }\n      } else {\n        // unknown subsection\n        offset += subsectionSize;\n      }\n    }\n  }\n  return customSection;\n};\n\n/**\n     * @param {number} ptr\n     * @param {string} type\n     */ function getValue(ptr, type = \"i8\") {\n  if (type.endsWith(\"*\")) type = \"*\";\n  switch (type) {\n   case \"i1\":\n    return HEAP8[ptr];\n\n   case \"i8\":\n    return HEAP8[ptr];\n\n   case \"i16\":\n    return LE_HEAP_LOAD_I16(((ptr) >> 1) * 2);\n\n   case \"i32\":\n    return LE_HEAP_LOAD_I32(((ptr) >> 2) * 4);\n\n   case \"i64\":\n    return HEAP64[((ptr) >> 3)];\n\n   case \"float\":\n    return LE_HEAP_LOAD_F32(((ptr) >> 2) * 4);\n\n   case \"double\":\n    return LE_HEAP_LOAD_F64(((ptr) >> 3) * 8);\n\n   case \"*\":\n    return LE_HEAP_LOAD_U32(((ptr) >> 2) * 4);\n\n   default:\n    abort(`invalid type for getValue: ${type}`);\n  }\n}\n\nvar newDSO = (name, handle, syms) => {\n  var dso = {\n    refcount: Infinity,\n    name,\n    exports: syms,\n    global: true\n  };\n  LDSO.loadedLibsByName[name] = dso;\n  if (handle != undefined) {\n    LDSO.loadedLibsByHandle[handle] = dso;\n  }\n  return dso;\n};\n\nvar LDSO = {\n  loadedLibsByName: {},\n  loadedLibsByHandle: {},\n  init() {\n    newDSO(\"__main__\", 0, wasmImports);\n  }\n};\n\nvar ___heap_base = 78224;\n\nvar alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;\n\nvar getMemory = size => {\n  // After the runtime is initialized, we must only use sbrk() normally.\n  if (runtimeInitialized) {\n    // Currently we don't support freeing of static data when modules are\n    // unloaded via dlclose.  This function is tagged as `noleakcheck` to\n    // avoid having this reported as leak.\n    return _calloc(size, 1);\n  }\n  var ret = ___heap_base;\n  // Keep __heap_base stack aligned.\n  var end = ret + alignMemory(size, 16);\n  ___heap_base = end;\n  GOT[\"__heap_base\"].value = end;\n  return ret;\n};\n\nvar isInternalSym = symName => [ \"__cpp_exception\", \"__c_longjmp\", \"__wasm_apply_data_relocs\", \"__dso_handle\", \"__tls_size\", \"__tls_align\", \"__set_stack_limits\", \"_emscripten_tls_init\", \"__wasm_init_tls\", \"__wasm_call_ctors\", \"__start_em_asm\", \"__stop_em_asm\", \"__start_em_js\", \"__stop_em_js\" ].includes(symName) || symName.startsWith(\"__em_js__\");\n\nvar uleb128Encode = (n, target) => {\n  if (n < 128) {\n    target.push(n);\n  } else {\n    target.push((n % 128) | 128, n >> 7);\n  }\n};\n\nvar sigToWasmTypes = sig => {\n  var typeNames = {\n    \"i\": \"i32\",\n    \"j\": \"i64\",\n    \"f\": \"f32\",\n    \"d\": \"f64\",\n    \"e\": \"externref\",\n    \"p\": \"i32\"\n  };\n  var type = {\n    parameters: [],\n    results: sig[0] == \"v\" ? [] : [ typeNames[sig[0]] ]\n  };\n  for (var i = 1; i < sig.length; ++i) {\n    type.parameters.push(typeNames[sig[i]]);\n  }\n  return type;\n};\n\nvar generateFuncType = (sig, target) => {\n  var sigRet = sig.slice(0, 1);\n  var sigParam = sig.slice(1);\n  var typeCodes = {\n    \"i\": 127,\n    // i32\n    \"p\": 127,\n    // i32\n    \"j\": 126,\n    // i64\n    \"f\": 125,\n    // f32\n    \"d\": 124,\n    // f64\n    \"e\": 111\n  };\n  // Parameters, length + signatures\n  target.push(96);\n  uleb128Encode(sigParam.length, target);\n  for (var i = 0; i < sigParam.length; ++i) {\n    target.push(typeCodes[sigParam[i]]);\n  }\n  // Return values, length + signatures\n  // With no multi-return in MVP, either 0 (void) or 1 (anything else)\n  if (sigRet == \"v\") {\n    target.push(0);\n  } else {\n    target.push(1, typeCodes[sigRet]);\n  }\n};\n\nvar convertJsFunctionToWasm = (func, sig) => {\n  // If the type reflection proposal is available, use the new\n  // \"WebAssembly.Function\" constructor.\n  // Otherwise, construct a minimal wasm module importing the JS function and\n  // re-exporting it.\n  if (typeof WebAssembly.Function == \"function\") {\n    return new WebAssembly.Function(sigToWasmTypes(sig), func);\n  }\n  // The module is static, with the exception of the type section, which is\n  // generated based on the signature passed in.\n  var typeSectionBody = [ 1 ];\n  generateFuncType(sig, typeSectionBody);\n  // Rest of the module is static\n  var bytes = [ 0, 97, 115, 109, // magic (\"\\0asm\")\n  1, 0, 0, 0, // version: 1\n  1 ];\n  // Write the overall length of the type section followed by the body\n  uleb128Encode(typeSectionBody.length, bytes);\n  bytes.push(...typeSectionBody);\n  // The rest of the module is static\n  bytes.push(2, 7, // import section\n  // (import \"e\" \"f\" (func 0 (type 0)))\n  1, 1, 101, 1, 102, 0, 0, 7, 5, // export section\n  // (export \"f\" (func 0 (type 0)))\n  1, 1, 102, 0, 0);\n  // We can compile this wasm module synchronously because it is very small.\n  // This accepts an import (at \"e.f\"), that it reroutes to an export (at \"f\")\n  var module = new WebAssembly.Module(new Uint8Array(bytes));\n  var instance = new WebAssembly.Instance(module, {\n    \"e\": {\n      \"f\": func\n    }\n  });\n  var wrappedFunc = instance.exports[\"f\"];\n  return wrappedFunc;\n};\n\nvar wasmTableMirror = [];\n\n/** @type {WebAssembly.Table} */ var wasmTable = new WebAssembly.Table({\n  \"initial\": 31,\n  \"element\": \"anyfunc\"\n});\n\nvar getWasmTableEntry = funcPtr => {\n  var func = wasmTableMirror[funcPtr];\n  if (!func) {\n    if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n    /** @suppress {checkTypes} */ wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n  }\n  return func;\n};\n\nvar updateTableMap = (offset, count) => {\n  if (functionsInTableMap) {\n    for (var i = offset; i < offset + count; i++) {\n      var item = getWasmTableEntry(i);\n      // Ignore null values.\n      if (item) {\n        functionsInTableMap.set(item, i);\n      }\n    }\n  }\n};\n\nvar functionsInTableMap;\n\nvar getFunctionAddress = func => {\n  // First, create the map if this is the first use.\n  if (!functionsInTableMap) {\n    functionsInTableMap = new WeakMap;\n    updateTableMap(0, wasmTable.length);\n  }\n  return functionsInTableMap.get(func) || 0;\n};\n\nvar freeTableIndexes = [];\n\nvar getEmptyTableSlot = () => {\n  // Reuse a free index if there is one, otherwise grow.\n  if (freeTableIndexes.length) {\n    return freeTableIndexes.pop();\n  }\n  // Grow the table\n  try {\n    /** @suppress {checkTypes} */ wasmTable.grow(1);\n  } catch (err) {\n    if (!(err instanceof RangeError)) {\n      throw err;\n    }\n    throw \"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.\";\n  }\n  return wasmTable.length - 1;\n};\n\nvar setWasmTableEntry = (idx, func) => {\n  /** @suppress {checkTypes} */ wasmTable.set(idx, func);\n  // With ABORT_ON_WASM_EXCEPTIONS wasmTable.get is overridden to return wrapped\n  // functions so we need to call it here to retrieve the potential wrapper correctly\n  // instead of just storing 'func' directly into wasmTableMirror\n  /** @suppress {checkTypes} */ wasmTableMirror[idx] = wasmTable.get(idx);\n};\n\n/** @param {string=} sig */ var addFunction = (func, sig) => {\n  // Check if the function is already in the table, to ensure each function\n  // gets a unique index.\n  var rtn = getFunctionAddress(func);\n  if (rtn) {\n    return rtn;\n  }\n  // It's not in the table, add it now.\n  var ret = getEmptyTableSlot();\n  // Set the new value.\n  try {\n    // Attempting to call this with JS function will cause of table.set() to fail\n    setWasmTableEntry(ret, func);\n  } catch (err) {\n    if (!(err instanceof TypeError)) {\n      throw err;\n    }\n    var wrapped = convertJsFunctionToWasm(func, sig);\n    setWasmTableEntry(ret, wrapped);\n  }\n  functionsInTableMap.set(func, ret);\n  return ret;\n};\n\nvar updateGOT = (exports, replace) => {\n  for (var symName in exports) {\n    if (isInternalSym(symName)) {\n      continue;\n    }\n    var value = exports[symName];\n    GOT[symName] ||= new WebAssembly.Global({\n      \"value\": \"i32\",\n      \"mutable\": true\n    });\n    if (replace || GOT[symName].value == 0) {\n      if (typeof value == \"function\") {\n        GOT[symName].value = addFunction(value);\n      } else if (typeof value == \"number\") {\n        GOT[symName].value = value;\n      } else {\n        err(`unhandled export type for '${symName}': ${typeof value}`);\n      }\n    }\n  }\n};\n\n/** @param {boolean=} replace */ var relocateExports = (exports, memoryBase, replace) => {\n  var relocated = {};\n  for (var e in exports) {\n    var value = exports[e];\n    if (typeof value == \"object\") {\n      // a breaking change in the wasm spec, globals are now objects\n      // https://github.com/WebAssembly/mutable-global/issues/1\n      value = value.value;\n    }\n    if (typeof value == \"number\") {\n      value += memoryBase;\n    }\n    relocated[e] = value;\n  }\n  updateGOT(relocated, replace);\n  return relocated;\n};\n\nvar isSymbolDefined = symName => {\n  // Ignore 'stub' symbols that are auto-generated as part of the original\n  // `wasmImports` used to instantiate the main module.\n  var existing = wasmImports[symName];\n  if (!existing || existing.stub) {\n    return false;\n  }\n  return true;\n};\n\nvar dynCall = (sig, ptr, args = []) => {\n  var rtn = getWasmTableEntry(ptr)(...args);\n  return rtn;\n};\n\nvar stackSave = () => _emscripten_stack_get_current();\n\nvar stackRestore = val => __emscripten_stack_restore(val);\n\nvar createInvokeFunction = sig => (ptr, ...args) => {\n  var sp = stackSave();\n  try {\n    return dynCall(sig, ptr, args);\n  } catch (e) {\n    stackRestore(sp);\n    // Create a try-catch guard that rethrows the Emscripten EH exception.\n    // Exceptions thrown from C++ will be a pointer (number) and longjmp\n    // will throw the number Infinity. Use the compact and fast \"e !== e+0\"\n    // test to check if e was not a Number.\n    if (e !== e + 0) throw e;\n    _setThrew(1, 0);\n    // In theory this if statement could be done on\n    // creating the function, but I just added this to\n    // save wasting code space as it only happens on exception.\n    if (sig[0] == \"j\") return 0n;\n  }\n};\n\nvar resolveGlobalSymbol = (symName, direct = false) => {\n  var sym;\n  if (isSymbolDefined(symName)) {\n    sym = wasmImports[symName];\n  } else if (symName.startsWith(\"invoke_\")) {\n    // Create (and cache) new invoke_ functions on demand.\n    sym = wasmImports[symName] = createInvokeFunction(symName.split(\"_\")[1]);\n  }\n  return {\n    sym,\n    name: symName\n  };\n};\n\nvar onPostCtors = [];\n\nvar addOnPostCtor = cb => onPostCtors.unshift(cb);\n\n/**\n     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\n     * emscripten HEAP, returns a copy of that string as a Javascript String object.\n     *\n     * @param {number} ptr\n     * @param {number=} maxBytesToRead - An optional length that specifies the\n     *   maximum number of bytes to read. You can omit this parameter to scan the\n     *   string until the first 0 byte. If maxBytesToRead is passed, and the string\n     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\n     *   string will cut short at that byte index (i.e. maxBytesToRead will not\n     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing\n     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw\n     *   JS JIT optimizations off, so it is worth to consider consistently using one\n     * @return {string}\n     */ var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n\n/**\n      * @param {string=} libName\n      * @param {Object=} localScope\n      * @param {number=} handle\n      */ var loadWebAssemblyModule = (binary, flags, libName, localScope, handle) => {\n  var metadata = getDylinkMetadata(binary);\n  currentModuleWeakSymbols = metadata.weakImports;\n  // loadModule loads the wasm module after all its dependencies have been loaded.\n  // can be called both sync/async.\n  function loadModule() {\n    // alignments are powers of 2\n    var memAlign = Math.pow(2, metadata.memoryAlign);\n    // prepare memory\n    var memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0;\n    // TODO: add to cleanups\n    var tableBase = metadata.tableSize ? wasmTable.length : 0;\n    if (handle) {\n      HEAP8[(handle) + (8)] = 1;\n      LE_HEAP_STORE_U32((((handle) + (12)) >> 2) * 4, memoryBase);\n      LE_HEAP_STORE_I32((((handle) + (16)) >> 2) * 4, metadata.memorySize);\n      LE_HEAP_STORE_U32((((handle) + (20)) >> 2) * 4, tableBase);\n      LE_HEAP_STORE_I32((((handle) + (24)) >> 2) * 4, metadata.tableSize);\n    }\n    if (metadata.tableSize) {\n      wasmTable.grow(metadata.tableSize);\n    }\n    // This is the export map that we ultimately return.  We declare it here\n    // so it can be used within resolveSymbol.  We resolve symbols against\n    // this local symbol map in the case there they are not present on the\n    // global Module object.  We need this fallback because Modules sometime\n    // need to import their own symbols\n    var moduleExports;\n    function resolveSymbol(sym) {\n      var resolved = resolveGlobalSymbol(sym).sym;\n      if (!resolved && localScope) {\n        resolved = localScope[sym];\n      }\n      if (!resolved) {\n        resolved = moduleExports[sym];\n      }\n      return resolved;\n    }\n    // TODO kill  (except \"symbols local to this module\", it will likely be\n    // not needed if we require that if A wants symbols from B it has to link\n    // to B explicitly: similarly to -Wl,--no-undefined)\n    // wasm dynamic libraries are pure wasm, so they cannot assist in\n    // their own loading. When side module A wants to import something\n    // provided by a side module B that is loaded later, we need to\n    // add a layer of indirection, but worse, we can't even tell what\n    // to add the indirection for, without inspecting what A's imports\n    // are. To do that here, we use a JS proxy (another option would\n    // be to inspect the binary directly).\n    var proxyHandler = {\n      get(stubs, prop) {\n        // symbols that should be local to this module\n        switch (prop) {\n         case \"__memory_base\":\n          return memoryBase;\n\n         case \"__table_base\":\n          return tableBase;\n        }\n        if (prop in wasmImports && !wasmImports[prop].stub) {\n          // No stub needed, symbol already exists in symbol table\n          var res = wasmImports[prop];\n          return res;\n        }\n        // Return a stub function that will resolve the symbol\n        // when first called.\n        if (!(prop in stubs)) {\n          var resolved;\n          stubs[prop] = (...args) => {\n            resolved ||= resolveSymbol(prop);\n            return resolved(...args);\n          };\n        }\n        return stubs[prop];\n      }\n    };\n    var proxy = new Proxy({}, proxyHandler);\n    var info = {\n      \"GOT.mem\": new Proxy({}, GOTHandler),\n      \"GOT.func\": new Proxy({}, GOTHandler),\n      \"env\": proxy,\n      \"wasi_snapshot_preview1\": proxy\n    };\n    function postInstantiation(module, instance) {\n      // add new entries to functionsInTableMap\n      updateTableMap(tableBase, metadata.tableSize);\n      moduleExports = relocateExports(instance.exports, memoryBase);\n      if (!flags.allowUndefined) {\n        reportUndefinedSymbols();\n      }\n      function addEmAsm(addr, body) {\n        var args = [];\n        var arity = 0;\n        for (;arity < 16; arity++) {\n          if (body.indexOf(\"$\" + arity) != -1) {\n            args.push(\"$\" + arity);\n          } else {\n            break;\n          }\n        }\n        args = args.join(\",\");\n        var func = `(${args}) => { ${body} };`;\n        ASM_CONSTS[start] = eval(func);\n      }\n      // Add any EM_ASM function that exist in the side module\n      if (\"__start_em_asm\" in moduleExports) {\n        var start = moduleExports[\"__start_em_asm\"];\n        var stop = moduleExports[\"__stop_em_asm\"];\n        while (start < stop) {\n          var jsString = UTF8ToString(start);\n          addEmAsm(start, jsString);\n          start = HEAPU8.indexOf(0, start) + 1;\n        }\n      }\n      function addEmJs(name, cSig, body) {\n        // The signature here is a C signature (e.g. \"(int foo, char* bar)\").\n        // See `create_em_js` in emcc.py` for the build-time version of this\n        // code.\n        var jsArgs = [];\n        cSig = cSig.slice(1, -1);\n        if (cSig != \"void\") {\n          cSig = cSig.split(\",\");\n          for (var i in cSig) {\n            var jsArg = cSig[i].split(\" \").pop();\n            jsArgs.push(jsArg.replace(\"*\", \"\"));\n          }\n        }\n        var func = `(${jsArgs}) => ${body};`;\n        moduleExports[name] = eval(func);\n      }\n      for (var name in moduleExports) {\n        if (name.startsWith(\"__em_js__\")) {\n          var start = moduleExports[name];\n          var jsString = UTF8ToString(start);\n          // EM_JS strings are stored in the data section in the form\n          // SIG<::>BODY.\n          var parts = jsString.split(\"<::>\");\n          addEmJs(name.replace(\"__em_js__\", \"\"), parts[0], parts[1]);\n          delete moduleExports[name];\n        }\n      }\n      // initialize the module\n      var applyRelocs = moduleExports[\"__wasm_apply_data_relocs\"];\n      if (applyRelocs) {\n        if (runtimeInitialized) {\n          applyRelocs();\n        } else {\n          __RELOC_FUNCS__.push(applyRelocs);\n        }\n      }\n      var init = moduleExports[\"__wasm_call_ctors\"];\n      if (init) {\n        if (runtimeInitialized) {\n          init();\n        } else {\n          // we aren't ready to run compiled code yet\n          addOnPostCtor(init);\n        }\n      }\n      return moduleExports;\n    }\n    if (flags.loadAsync) {\n      if (binary instanceof WebAssembly.Module) {\n        var instance = new WebAssembly.Instance(binary, info);\n        return Promise.resolve(postInstantiation(binary, instance));\n      }\n      return WebAssembly.instantiate(binary, info).then(result => postInstantiation(result.module, result.instance));\n    }\n    var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary);\n    var instance = new WebAssembly.Instance(module, info);\n    return postInstantiation(module, instance);\n  }\n  // now load needed libraries and the module itself.\n  if (flags.loadAsync) {\n    return metadata.neededDynlibs.reduce((chain, dynNeeded) => chain.then(() => loadDynamicLibrary(dynNeeded, flags, localScope)), Promise.resolve()).then(loadModule);\n  }\n  metadata.neededDynlibs.forEach(needed => loadDynamicLibrary(needed, flags, localScope));\n  return loadModule();\n};\n\nvar mergeLibSymbols = (exports, libName) => {\n  // add symbols into global namespace TODO: weak linking etc.\n  for (var [sym, exp] of Object.entries(exports)) {\n    // When RTLD_GLOBAL is enabled, the symbols defined by this shared object\n    // will be made available for symbol resolution of subsequently loaded\n    // shared objects.\n    // We should copy the symbols (which include methods and variables) from\n    // SIDE_MODULE to MAIN_MODULE.\n    const setImport = target => {\n      if (!isSymbolDefined(target)) {\n        wasmImports[target] = exp;\n      }\n    };\n    setImport(sym);\n    // Special case for handling of main symbol:  If a side module exports\n    // `main` that also acts a definition for `__main_argc_argv` and vice\n    // versa.\n    const main_alias = \"__main_argc_argv\";\n    if (sym == \"main\") {\n      setImport(main_alias);\n    }\n    if (sym == main_alias) {\n      setImport(\"main\");\n    }\n  }\n};\n\nvar asyncLoad = async url => {\n  var arrayBuffer = await readAsync(url);\n  return new Uint8Array(arrayBuffer);\n};\n\n/**\n       * @param {number=} handle\n       * @param {Object=} localScope\n       */ function loadDynamicLibrary(libName, flags = {\n  global: true,\n  nodelete: true\n}, localScope, handle) {\n  // when loadDynamicLibrary did not have flags, libraries were loaded\n  // globally & permanently\n  var dso = LDSO.loadedLibsByName[libName];\n  if (dso) {\n    // the library is being loaded or has been loaded already.\n    if (!flags.global) {\n      if (localScope) {\n        Object.assign(localScope, dso.exports);\n      }\n    } else if (!dso.global) {\n      // The library was previously loaded only locally but not\n      // we have a request with global=true.\n      dso.global = true;\n      mergeLibSymbols(dso.exports, libName);\n    }\n    // same for \"nodelete\"\n    if (flags.nodelete && dso.refcount !== Infinity) {\n      dso.refcount = Infinity;\n    }\n    dso.refcount++;\n    if (handle) {\n      LDSO.loadedLibsByHandle[handle] = dso;\n    }\n    return flags.loadAsync ? Promise.resolve(true) : true;\n  }\n  // allocate new DSO\n  dso = newDSO(libName, handle, \"loading\");\n  dso.refcount = flags.nodelete ? Infinity : 1;\n  dso.global = flags.global;\n  // libName -> libData\n  function loadLibData() {\n    // for wasm, we can use fetch for async, but for fs mode we can only imitate it\n    if (handle) {\n      var data = LE_HEAP_LOAD_U32((((handle) + (28)) >> 2) * 4);\n      var dataSize = LE_HEAP_LOAD_U32((((handle) + (32)) >> 2) * 4);\n      if (data && dataSize) {\n        var libData = HEAP8.slice(data, data + dataSize);\n        return flags.loadAsync ? Promise.resolve(libData) : libData;\n      }\n    }\n    var libFile = locateFile(libName);\n    if (flags.loadAsync) {\n      return asyncLoad(libFile);\n    }\n    // load the binary synchronously\n    if (!readBinary) {\n      throw new Error(`${libFile}: file not found, and synchronous loading of external files is not available`);\n    }\n    return readBinary(libFile);\n  }\n  // libName -> exports\n  function getExports() {\n    // module not preloaded - load lib data and create new module from it\n    if (flags.loadAsync) {\n      return loadLibData().then(libData => loadWebAssemblyModule(libData, flags, libName, localScope, handle));\n    }\n    return loadWebAssemblyModule(loadLibData(), flags, libName, localScope, handle);\n  }\n  // module for lib is loaded - update the dso & global namespace\n  function moduleLoaded(exports) {\n    if (dso.global) {\n      mergeLibSymbols(exports, libName);\n    } else if (localScope) {\n      Object.assign(localScope, exports);\n    }\n    dso.exports = exports;\n  }\n  if (flags.loadAsync) {\n    return getExports().then(exports => {\n      moduleLoaded(exports);\n      return true;\n    });\n  }\n  moduleLoaded(getExports());\n  return true;\n}\n\nvar reportUndefinedSymbols = () => {\n  for (var [symName, entry] of Object.entries(GOT)) {\n    if (entry.value == 0) {\n      var value = resolveGlobalSymbol(symName, true).sym;\n      if (!value && !entry.required) {\n        // Ignore undefined symbols that are imported as weak.\n        continue;\n      }\n      if (typeof value == \"function\") {\n        /** @suppress {checkTypes} */ entry.value = addFunction(value, value.sig);\n      } else if (typeof value == \"number\") {\n        entry.value = value;\n      } else {\n        throw new Error(`bad export type for '${symName}': ${typeof value}`);\n      }\n    }\n  }\n};\n\nvar loadDylibs = () => {\n  if (!dynamicLibraries.length) {\n    reportUndefinedSymbols();\n    return;\n  }\n  // Load binaries asynchronously\n  addRunDependency(\"loadDylibs\");\n  dynamicLibraries.reduce((chain, lib) => chain.then(() => loadDynamicLibrary(lib, {\n    loadAsync: true,\n    global: true,\n    nodelete: true,\n    allowUndefined: true\n  })), Promise.resolve()).then(() => {\n    // we got them all, wonderful\n    reportUndefinedSymbols();\n    removeRunDependency(\"loadDylibs\");\n  });\n};\n\nvar noExitRuntime = Module[\"noExitRuntime\"] || true;\n\n/**\n     * @param {number} ptr\n     * @param {number} value\n     * @param {string} type\n     */ function setValue(ptr, value, type = \"i8\") {\n  if (type.endsWith(\"*\")) type = \"*\";\n  switch (type) {\n   case \"i1\":\n    HEAP8[ptr] = value;\n    break;\n\n   case \"i8\":\n    HEAP8[ptr] = value;\n    break;\n\n   case \"i16\":\n    LE_HEAP_STORE_I16(((ptr) >> 1) * 2, value);\n    break;\n\n   case \"i32\":\n    LE_HEAP_STORE_I32(((ptr) >> 2) * 4, value);\n    break;\n\n   case \"i64\":\n    HEAP64[((ptr) >> 3)] = BigInt(value);\n    break;\n\n   case \"float\":\n    LE_HEAP_STORE_F32(((ptr) >> 2) * 4, value);\n    break;\n\n   case \"double\":\n    LE_HEAP_STORE_F64(((ptr) >> 3) * 8, value);\n    break;\n\n   case \"*\":\n    LE_HEAP_STORE_U32(((ptr) >> 2) * 4, value);\n    break;\n\n   default:\n    abort(`invalid type for setValue: ${type}`);\n  }\n}\n\nvar ___memory_base = new WebAssembly.Global({\n  \"value\": \"i32\",\n  \"mutable\": false\n}, 1024);\n\nvar ___stack_pointer = new WebAssembly.Global({\n  \"value\": \"i32\",\n  \"mutable\": true\n}, 78224);\n\nvar ___table_base = new WebAssembly.Global({\n  \"value\": \"i32\",\n  \"mutable\": false\n}, 1);\n\nvar __abort_js = () => abort(\"\");\n\n__abort_js.sig = \"v\";\n\nvar _emscripten_get_now = () => performance.now();\n\n_emscripten_get_now.sig = \"d\";\n\nvar _emscripten_date_now = () => Date.now();\n\n_emscripten_date_now.sig = \"d\";\n\nvar nowIsMonotonic = 1;\n\nvar checkWasiClock = clock_id => clock_id >= 0 && clock_id <= 3;\n\nvar INT53_MAX = 9007199254740992;\n\nvar INT53_MIN = -9007199254740992;\n\nvar bigintToI53Checked = num => (num < INT53_MIN || num > INT53_MAX) ? NaN : Number(num);\n\nfunction _clock_time_get(clk_id, ignored_precision, ptime) {\n  ignored_precision = bigintToI53Checked(ignored_precision);\n  if (!checkWasiClock(clk_id)) {\n    return 28;\n  }\n  var now;\n  // all wasi clocks but realtime are monotonic\n  if (clk_id === 0) {\n    now = _emscripten_date_now();\n  } else if (nowIsMonotonic) {\n    now = _emscripten_get_now();\n  } else {\n    return 52;\n  }\n  // \"now\" is in ms, and wasi times are in ns.\n  var nsec = Math.round(now * 1e3 * 1e3);\n  HEAP64[((ptime) >> 3)] = BigInt(nsec);\n  return 0;\n}\n\n_clock_time_get.sig = \"iijp\";\n\nvar getHeapMax = () => // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate\n// full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side\n// for any code that deals with heap sizes, which would require special\n// casing all heap size related code to treat 0 specially.\n2147483648;\n\nvar growMemory = size => {\n  var b = wasmMemory.buffer;\n  var pages = ((size - b.byteLength + 65535) / 65536) | 0;\n  try {\n    // round size grow request up to wasm page size (fixed 64KB per spec)\n    wasmMemory.grow(pages);\n    // .grow() takes a delta compared to the previous size\n    updateMemoryViews();\n    return 1;\n  } catch (e) {}\n};\n\nvar _emscripten_resize_heap = requestedSize => {\n  var oldSize = HEAPU8.length;\n  // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n  requestedSize >>>= 0;\n  // With multithreaded builds, races can happen (another thread might increase the size\n  // in between), so return a failure, and let the caller retry.\n  // Memory resize rules:\n  // 1.  Always increase heap size to at least the requested size, rounded up\n  //     to next page multiple.\n  // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap\n  //     geometrically: increase the heap size according to\n  //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most\n  //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).\n  // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap\n  //     linearly: increase the heap size by at least\n  //     MEMORY_GROWTH_LINEAR_STEP bytes.\n  // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by\n  //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest\n  // 4.  If we were unable to allocate as much memory, it may be due to\n  //     over-eager decision to excessively reserve due to (3) above.\n  //     Hence if an allocation fails, cut down on the amount of excess\n  //     growth, in an attempt to succeed to perform a smaller allocation.\n  // A limit is set for how much we can grow. We should not exceed that\n  // (the wasm binary specifies it, so if we tried, we'd fail anyhow).\n  var maxHeapSize = getHeapMax();\n  if (requestedSize > maxHeapSize) {\n    return false;\n  }\n  // Loop through potential heap size increases. If we attempt a too eager\n  // reservation that fails, cut down on the attempted size and reserve a\n  // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)\n  for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n    var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n    // ensure geometric growth\n    // but limit overreserving (default to capping at +96MB overgrowth at most)\n    overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n    var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));\n    var replacement = growMemory(newSize);\n    if (replacement) {\n      return true;\n    }\n  }\n  return false;\n};\n\n_emscripten_resize_heap.sig = \"ip\";\n\nvar _fd_close = fd => 52;\n\n_fd_close.sig = \"ii\";\n\nfunction _fd_seek(fd, offset, whence, newOffset) {\n  offset = bigintToI53Checked(offset);\n  return 70;\n}\n\n_fd_seek.sig = \"iijip\";\n\nvar printCharBuffers = [ null, [], [] ];\n\nvar printChar = (stream, curr) => {\n  var buffer = printCharBuffers[stream];\n  if (curr === 0 || curr === 10) {\n    (stream === 1 ? out : err)(UTF8ArrayToString(buffer));\n    buffer.length = 0;\n  } else {\n    buffer.push(curr);\n  }\n};\n\nvar flush_NO_FILESYSTEM = () => {\n  // flush anything remaining in the buffers during shutdown\n  if (printCharBuffers[1].length) printChar(1, 10);\n  if (printCharBuffers[2].length) printChar(2, 10);\n};\n\nvar SYSCALLS = {\n  varargs: undefined,\n  getStr(ptr) {\n    var ret = UTF8ToString(ptr);\n    return ret;\n  }\n};\n\nvar _fd_write = (fd, iov, iovcnt, pnum) => {\n  // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0\n  var num = 0;\n  for (var i = 0; i < iovcnt; i++) {\n    var ptr = LE_HEAP_LOAD_U32(((iov) >> 2) * 4);\n    var len = LE_HEAP_LOAD_U32((((iov) + (4)) >> 2) * 4);\n    iov += 8;\n    for (var j = 0; j < len; j++) {\n      printChar(fd, HEAPU8[ptr + j]);\n    }\n    num += len;\n  }\n  LE_HEAP_STORE_U32(((pnum) >> 2) * 4, num);\n  return 0;\n};\n\n_fd_write.sig = \"iippp\";\n\nfunction _tree_sitter_log_callback(isLexMessage, messageAddress) {\n  if (Module.currentLogCallback) {\n    const message = UTF8ToString(messageAddress);\n    Module.currentLogCallback(message, isLexMessage !== 0);\n  }\n}\n\nfunction _tree_sitter_parse_callback(inputBufferAddress, index, row, column, lengthAddress) {\n  const INPUT_BUFFER_SIZE = 10 * 1024;\n  const string = Module.currentParseCallback(index, {\n    row,\n    column\n  });\n  if (typeof string === \"string\") {\n    setValue(lengthAddress, string.length, \"i32\");\n    stringToUTF16(string, inputBufferAddress, INPUT_BUFFER_SIZE);\n  } else {\n    setValue(lengthAddress, 0, \"i32\");\n  }\n}\n\nfunction _tree_sitter_progress_callback(currentOffset, hasError) {\n  if (Module.currentProgressCallback) {\n    return Module.currentProgressCallback({\n      currentOffset,\n      hasError\n    });\n  }\n  return false;\n}\n\nfunction _tree_sitter_query_progress_callback(currentOffset) {\n  if (Module.currentQueryProgressCallback) {\n    return Module.currentQueryProgressCallback({\n      currentOffset\n    });\n  }\n  return false;\n}\n\nvar runtimeKeepaliveCounter = 0;\n\nvar keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;\n\nvar _proc_exit = code => {\n  EXITSTATUS = code;\n  if (!keepRuntimeAlive()) {\n    Module[\"onExit\"]?.(code);\n    ABORT = true;\n  }\n  quit_(code, new ExitStatus(code));\n};\n\n_proc_exit.sig = \"vi\";\n\n/** @param {boolean|number=} implicit */ var exitJS = (status, implicit) => {\n  EXITSTATUS = status;\n  _proc_exit(status);\n};\n\nvar handleException = e => {\n  // Certain exception types we do not treat as errors since they are used for\n  // internal control flow.\n  // 1. ExitStatus, which is thrown by exit()\n  // 2. \"unwind\", which is thrown by emscripten_unwind_to_js_event_loop() and others\n  //    that wish to return to JS event loop.\n  if (e instanceof ExitStatus || e == \"unwind\") {\n    return EXITSTATUS;\n  }\n  quit_(1, e);\n};\n\nvar lengthBytesUTF8 = str => {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n    // unit, not a Unicode code point of the character! So decode\n    // UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var c = str.charCodeAt(i);\n    // possibly a lead surrogate\n    if (c <= 127) {\n      len++;\n    } else if (c <= 2047) {\n      len += 2;\n    } else if (c >= 55296 && c <= 57343) {\n      len += 4;\n      ++i;\n    } else {\n      len += 3;\n    }\n  }\n  return len;\n};\n\nvar stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n  // Parameter maxBytesToWrite is not optional. Negative values, 0, null,\n  // undefined and false each don't write out any bytes.\n  if (!(maxBytesToWrite > 0)) return 0;\n  var startIdx = outIdx;\n  var endIdx = outIdx + maxBytesToWrite - 1;\n  // -1 for string null terminator.\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n    // unit, not a Unicode code point of the character! So decode\n    // UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description\n    // and https://www.ietf.org/rfc/rfc2279.txt\n    // and https://tools.ietf.org/html/rfc3629\n    var u = str.charCodeAt(i);\n    // possibly a lead surrogate\n    if (u >= 55296 && u <= 57343) {\n      var u1 = str.charCodeAt(++i);\n      u = 65536 + ((u & 1023) << 10) | (u1 & 1023);\n    }\n    if (u <= 127) {\n      if (outIdx >= endIdx) break;\n      heap[outIdx++] = u;\n    } else if (u <= 2047) {\n      if (outIdx + 1 >= endIdx) break;\n      heap[outIdx++] = 192 | (u >> 6);\n      heap[outIdx++] = 128 | (u & 63);\n    } else if (u <= 65535) {\n      if (outIdx + 2 >= endIdx) break;\n      heap[outIdx++] = 224 | (u >> 12);\n      heap[outIdx++] = 128 | ((u >> 6) & 63);\n      heap[outIdx++] = 128 | (u & 63);\n    } else {\n      if (outIdx + 3 >= endIdx) break;\n      heap[outIdx++] = 240 | (u >> 18);\n      heap[outIdx++] = 128 | ((u >> 12) & 63);\n      heap[outIdx++] = 128 | ((u >> 6) & 63);\n      heap[outIdx++] = 128 | (u & 63);\n    }\n  }\n  // Null-terminate the pointer to the buffer.\n  heap[outIdx] = 0;\n  return outIdx - startIdx;\n};\n\nvar stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n\nvar stackAlloc = sz => __emscripten_stack_alloc(sz);\n\nvar stringToUTF8OnStack = str => {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = stackAlloc(size);\n  stringToUTF8(str, ret, size);\n  return ret;\n};\n\nvar AsciiToString = ptr => {\n  var str = \"\";\n  while (1) {\n    var ch = HEAPU8[ptr++];\n    if (!ch) return str;\n    str += String.fromCharCode(ch);\n  }\n};\n\nvar stringToUTF16 = (str, outPtr, maxBytesToWrite) => {\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  maxBytesToWrite ??= 2147483647;\n  if (maxBytesToWrite < 2) return 0;\n  maxBytesToWrite -= 2;\n  // Null terminator.\n  var startPtr = outPtr;\n  var numCharsToWrite = (maxBytesToWrite < str.length * 2) ? (maxBytesToWrite / 2) : str.length;\n  for (var i = 0; i < numCharsToWrite; ++i) {\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n    var codeUnit = str.charCodeAt(i);\n    // possibly a lead surrogate\n    LE_HEAP_STORE_I16(((outPtr) >> 1) * 2, codeUnit);\n    outPtr += 2;\n  }\n  // Null-terminate the pointer to the HEAP.\n  LE_HEAP_STORE_I16(((outPtr) >> 1) * 2, 0);\n  return outPtr - startPtr;\n};\n\nvar wasmImports = {\n  /** @export */ __heap_base: ___heap_base,\n  /** @export */ __indirect_function_table: wasmTable,\n  /** @export */ __memory_base: ___memory_base,\n  /** @export */ __stack_pointer: ___stack_pointer,\n  /** @export */ __table_base: ___table_base,\n  /** @export */ _abort_js: __abort_js,\n  /** @export */ clock_time_get: _clock_time_get,\n  /** @export */ emscripten_resize_heap: _emscripten_resize_heap,\n  /** @export */ fd_close: _fd_close,\n  /** @export */ fd_seek: _fd_seek,\n  /** @export */ fd_write: _fd_write,\n  /** @export */ memory: wasmMemory,\n  /** @export */ tree_sitter_log_callback: _tree_sitter_log_callback,\n  /** @export */ tree_sitter_parse_callback: _tree_sitter_parse_callback,\n  /** @export */ tree_sitter_progress_callback: _tree_sitter_progress_callback,\n  /** @export */ tree_sitter_query_progress_callback: _tree_sitter_query_progress_callback\n};\n\nvar wasmExports = await createWasm();\n\nvar ___wasm_call_ctors = wasmExports[\"__wasm_call_ctors\"];\n\nvar _malloc = Module[\"_malloc\"] = wasmExports[\"malloc\"];\n\nvar _calloc = Module[\"_calloc\"] = wasmExports[\"calloc\"];\n\nvar _realloc = Module[\"_realloc\"] = wasmExports[\"realloc\"];\n\nvar _free = Module[\"_free\"] = wasmExports[\"free\"];\n\nvar _memcmp = Module[\"_memcmp\"] = wasmExports[\"memcmp\"];\n\nvar _ts_language_symbol_count = Module[\"_ts_language_symbol_count\"] = wasmExports[\"ts_language_symbol_count\"];\n\nvar _ts_language_state_count = Module[\"_ts_language_state_count\"] = wasmExports[\"ts_language_state_count\"];\n\nvar _ts_language_version = Module[\"_ts_language_version\"] = wasmExports[\"ts_language_version\"];\n\nvar _ts_language_abi_version = Module[\"_ts_language_abi_version\"] = wasmExports[\"ts_language_abi_version\"];\n\nvar _ts_language_metadata = Module[\"_ts_language_metadata\"] = wasmExports[\"ts_language_metadata\"];\n\nvar _ts_language_name = Module[\"_ts_language_name\"] = wasmExports[\"ts_language_name\"];\n\nvar _ts_language_field_count = Module[\"_ts_language_field_count\"] = wasmExports[\"ts_language_field_count\"];\n\nvar _ts_language_next_state = Module[\"_ts_language_next_state\"] = wasmExports[\"ts_language_next_state\"];\n\nvar _ts_language_symbol_name = Module[\"_ts_language_symbol_name\"] = wasmExports[\"ts_language_symbol_name\"];\n\nvar _ts_language_symbol_for_name = Module[\"_ts_language_symbol_for_name\"] = wasmExports[\"ts_language_symbol_for_name\"];\n\nvar _strncmp = Module[\"_strncmp\"] = wasmExports[\"strncmp\"];\n\nvar _ts_language_symbol_type = Module[\"_ts_language_symbol_type\"] = wasmExports[\"ts_language_symbol_type\"];\n\nvar _ts_language_field_name_for_id = Module[\"_ts_language_field_name_for_id\"] = wasmExports[\"ts_language_field_name_for_id\"];\n\nvar _ts_lookahead_iterator_new = Module[\"_ts_lookahead_iterator_new\"] = wasmExports[\"ts_lookahead_iterator_new\"];\n\nvar _ts_lookahead_iterator_delete = Module[\"_ts_lookahead_iterator_delete\"] = wasmExports[\"ts_lookahead_iterator_delete\"];\n\nvar _ts_lookahead_iterator_reset_state = Module[\"_ts_lookahead_iterator_reset_state\"] = wasmExports[\"ts_lookahead_iterator_reset_state\"];\n\nvar _ts_lookahead_iterator_reset = Module[\"_ts_lookahead_iterator_reset\"] = wasmExports[\"ts_lookahead_iterator_reset\"];\n\nvar _ts_lookahead_iterator_next = Module[\"_ts_lookahead_iterator_next\"] = wasmExports[\"ts_lookahead_iterator_next\"];\n\nvar _ts_lookahead_iterator_current_symbol = Module[\"_ts_lookahead_iterator_current_symbol\"] = wasmExports[\"ts_lookahead_iterator_current_symbol\"];\n\nvar _ts_parser_delete = Module[\"_ts_parser_delete\"] = wasmExports[\"ts_parser_delete\"];\n\nvar _ts_parser_reset = Module[\"_ts_parser_reset\"] = wasmExports[\"ts_parser_reset\"];\n\nvar _ts_parser_set_language = Module[\"_ts_parser_set_language\"] = wasmExports[\"ts_parser_set_language\"];\n\nvar _ts_parser_timeout_micros = Module[\"_ts_parser_timeout_micros\"] = wasmExports[\"ts_parser_timeout_micros\"];\n\nvar _ts_parser_set_timeout_micros = Module[\"_ts_parser_set_timeout_micros\"] = wasmExports[\"ts_parser_set_timeout_micros\"];\n\nvar _ts_parser_set_included_ranges = Module[\"_ts_parser_set_included_ranges\"] = wasmExports[\"ts_parser_set_included_ranges\"];\n\nvar _ts_query_new = Module[\"_ts_query_new\"] = wasmExports[\"ts_query_new\"];\n\nvar _ts_query_delete = Module[\"_ts_query_delete\"] = wasmExports[\"ts_query_delete\"];\n\nvar _iswspace = Module[\"_iswspace\"] = wasmExports[\"iswspace\"];\n\nvar _iswalnum = Module[\"_iswalnum\"] = wasmExports[\"iswalnum\"];\n\nvar _ts_query_pattern_count = Module[\"_ts_query_pattern_count\"] = wasmExports[\"ts_query_pattern_count\"];\n\nvar _ts_query_capture_count = Module[\"_ts_query_capture_count\"] = wasmExports[\"ts_query_capture_count\"];\n\nvar _ts_query_string_count = Module[\"_ts_query_string_count\"] = wasmExports[\"ts_query_string_count\"];\n\nvar _ts_query_capture_name_for_id = Module[\"_ts_query_capture_name_for_id\"] = wasmExports[\"ts_query_capture_name_for_id\"];\n\nvar _ts_query_capture_quantifier_for_id = Module[\"_ts_query_capture_quantifier_for_id\"] = wasmExports[\"ts_query_capture_quantifier_for_id\"];\n\nvar _ts_query_string_value_for_id = Module[\"_ts_query_string_value_for_id\"] = wasmExports[\"ts_query_string_value_for_id\"];\n\nvar _ts_query_predicates_for_pattern = Module[\"_ts_query_predicates_for_pattern\"] = wasmExports[\"ts_query_predicates_for_pattern\"];\n\nvar _ts_query_start_byte_for_pattern = Module[\"_ts_query_start_byte_for_pattern\"] = wasmExports[\"ts_query_start_byte_for_pattern\"];\n\nvar _ts_query_end_byte_for_pattern = Module[\"_ts_query_end_byte_for_pattern\"] = wasmExports[\"ts_query_end_byte_for_pattern\"];\n\nvar _ts_query_is_pattern_rooted = Module[\"_ts_query_is_pattern_rooted\"] = wasmExports[\"ts_query_is_pattern_rooted\"];\n\nvar _ts_query_is_pattern_non_local = Module[\"_ts_query_is_pattern_non_local\"] = wasmExports[\"ts_query_is_pattern_non_local\"];\n\nvar _ts_query_is_pattern_guaranteed_at_step = Module[\"_ts_query_is_pattern_guaranteed_at_step\"] = wasmExports[\"ts_query_is_pattern_guaranteed_at_step\"];\n\nvar _ts_query_disable_capture = Module[\"_ts_query_disable_capture\"] = wasmExports[\"ts_query_disable_capture\"];\n\nvar _ts_query_disable_pattern = Module[\"_ts_query_disable_pattern\"] = wasmExports[\"ts_query_disable_pattern\"];\n\nvar _ts_tree_copy = Module[\"_ts_tree_copy\"] = wasmExports[\"ts_tree_copy\"];\n\nvar _ts_tree_delete = Module[\"_ts_tree_delete\"] = wasmExports[\"ts_tree_delete\"];\n\nvar _ts_init = Module[\"_ts_init\"] = wasmExports[\"ts_init\"];\n\nvar _ts_parser_new_wasm = Module[\"_ts_parser_new_wasm\"] = wasmExports[\"ts_parser_new_wasm\"];\n\nvar _ts_parser_enable_logger_wasm = Module[\"_ts_parser_enable_logger_wasm\"] = wasmExports[\"ts_parser_enable_logger_wasm\"];\n\nvar _ts_parser_parse_wasm = Module[\"_ts_parser_parse_wasm\"] = wasmExports[\"ts_parser_parse_wasm\"];\n\nvar _ts_parser_included_ranges_wasm = Module[\"_ts_parser_included_ranges_wasm\"] = wasmExports[\"ts_parser_included_ranges_wasm\"];\n\nvar _ts_language_type_is_named_wasm = Module[\"_ts_language_type_is_named_wasm\"] = wasmExports[\"ts_language_type_is_named_wasm\"];\n\nvar _ts_language_type_is_visible_wasm = Module[\"_ts_language_type_is_visible_wasm\"] = wasmExports[\"ts_language_type_is_visible_wasm\"];\n\nvar _ts_language_supertypes_wasm = Module[\"_ts_language_supertypes_wasm\"] = wasmExports[\"ts_language_supertypes_wasm\"];\n\nvar _ts_language_subtypes_wasm = Module[\"_ts_language_subtypes_wasm\"] = wasmExports[\"ts_language_subtypes_wasm\"];\n\nvar _ts_tree_root_node_wasm = Module[\"_ts_tree_root_node_wasm\"] = wasmExports[\"ts_tree_root_node_wasm\"];\n\nvar _ts_tree_root_node_with_offset_wasm = Module[\"_ts_tree_root_node_with_offset_wasm\"] = wasmExports[\"ts_tree_root_node_with_offset_wasm\"];\n\nvar _ts_tree_edit_wasm = Module[\"_ts_tree_edit_wasm\"] = wasmExports[\"ts_tree_edit_wasm\"];\n\nvar _ts_tree_included_ranges_wasm = Module[\"_ts_tree_included_ranges_wasm\"] = wasmExports[\"ts_tree_included_ranges_wasm\"];\n\nvar _ts_tree_get_changed_ranges_wasm = Module[\"_ts_tree_get_changed_ranges_wasm\"] = wasmExports[\"ts_tree_get_changed_ranges_wasm\"];\n\nvar _ts_tree_cursor_new_wasm = Module[\"_ts_tree_cursor_new_wasm\"] = wasmExports[\"ts_tree_cursor_new_wasm\"];\n\nvar _ts_tree_cursor_copy_wasm = Module[\"_ts_tree_cursor_copy_wasm\"] = wasmExports[\"ts_tree_cursor_copy_wasm\"];\n\nvar _ts_tree_cursor_delete_wasm = Module[\"_ts_tree_cursor_delete_wasm\"] = wasmExports[\"ts_tree_cursor_delete_wasm\"];\n\nvar _ts_tree_cursor_reset_wasm = Module[\"_ts_tree_cursor_reset_wasm\"] = wasmExports[\"ts_tree_cursor_reset_wasm\"];\n\nvar _ts_tree_cursor_reset_to_wasm = Module[\"_ts_tree_cursor_reset_to_wasm\"] = wasmExports[\"ts_tree_cursor_reset_to_wasm\"];\n\nvar _ts_tree_cursor_goto_first_child_wasm = Module[\"_ts_tree_cursor_goto_first_child_wasm\"] = wasmExports[\"ts_tree_cursor_goto_first_child_wasm\"];\n\nvar _ts_tree_cursor_goto_last_child_wasm = Module[\"_ts_tree_cursor_goto_last_child_wasm\"] = wasmExports[\"ts_tree_cursor_goto_last_child_wasm\"];\n\nvar _ts_tree_cursor_goto_first_child_for_index_wasm = Module[\"_ts_tree_cursor_goto_first_child_for_index_wasm\"] = wasmExports[\"ts_tree_cursor_goto_first_child_for_index_wasm\"];\n\nvar _ts_tree_cursor_goto_first_child_for_position_wasm = Module[\"_ts_tree_cursor_goto_first_child_for_position_wasm\"] = wasmExports[\"ts_tree_cursor_goto_first_child_for_position_wasm\"];\n\nvar _ts_tree_cursor_goto_next_sibling_wasm = Module[\"_ts_tree_cursor_goto_next_sibling_wasm\"] = wasmExports[\"ts_tree_cursor_goto_next_sibling_wasm\"];\n\nvar _ts_tree_cursor_goto_previous_sibling_wasm = Module[\"_ts_tree_cursor_goto_previous_sibling_wasm\"] = wasmExports[\"ts_tree_cursor_goto_previous_sibling_wasm\"];\n\nvar _ts_tree_cursor_goto_descendant_wasm = Module[\"_ts_tree_cursor_goto_descendant_wasm\"] = wasmExports[\"ts_tree_cursor_goto_descendant_wasm\"];\n\nvar _ts_tree_cursor_goto_parent_wasm = Module[\"_ts_tree_cursor_goto_parent_wasm\"] = wasmExports[\"ts_tree_cursor_goto_parent_wasm\"];\n\nvar _ts_tree_cursor_current_node_type_id_wasm = Module[\"_ts_tree_cursor_current_node_type_id_wasm\"] = wasmExports[\"ts_tree_cursor_current_node_type_id_wasm\"];\n\nvar _ts_tree_cursor_current_node_state_id_wasm = Module[\"_ts_tree_cursor_current_node_state_id_wasm\"] = wasmExports[\"ts_tree_cursor_current_node_state_id_wasm\"];\n\nvar _ts_tree_cursor_current_node_is_named_wasm = Module[\"_ts_tree_cursor_current_node_is_named_wasm\"] = wasmExports[\"ts_tree_cursor_current_node_is_named_wasm\"];\n\nvar _ts_tree_cursor_current_node_is_missing_wasm = Module[\"_ts_tree_cursor_current_node_is_missing_wasm\"] = wasmExports[\"ts_tree_cursor_current_node_is_missing_wasm\"];\n\nvar _ts_tree_cursor_current_node_id_wasm = Module[\"_ts_tree_cursor_current_node_id_wasm\"] = wasmExports[\"ts_tree_cursor_current_node_id_wasm\"];\n\nvar _ts_tree_cursor_start_position_wasm = Module[\"_ts_tree_cursor_start_position_wasm\"] = wasmExports[\"ts_tree_cursor_start_position_wasm\"];\n\nvar _ts_tree_cursor_end_position_wasm = Module[\"_ts_tree_cursor_end_position_wasm\"] = wasmExports[\"ts_tree_cursor_end_position_wasm\"];\n\nvar _ts_tree_cursor_start_index_wasm = Module[\"_ts_tree_cursor_start_index_wasm\"] = wasmExports[\"ts_tree_cursor_start_index_wasm\"];\n\nvar _ts_tree_cursor_end_index_wasm = Module[\"_ts_tree_cursor_end_index_wasm\"] = wasmExports[\"ts_tree_cursor_end_index_wasm\"];\n\nvar _ts_tree_cursor_current_field_id_wasm = Module[\"_ts_tree_cursor_current_field_id_wasm\"] = wasmExports[\"ts_tree_cursor_current_field_id_wasm\"];\n\nvar _ts_tree_cursor_current_depth_wasm = Module[\"_ts_tree_cursor_current_depth_wasm\"] = wasmExports[\"ts_tree_cursor_current_depth_wasm\"];\n\nvar _ts_tree_cursor_current_descendant_index_wasm = Module[\"_ts_tree_cursor_current_descendant_index_wasm\"] = wasmExports[\"ts_tree_cursor_current_descendant_index_wasm\"];\n\nvar _ts_tree_cursor_current_node_wasm = Module[\"_ts_tree_cursor_current_node_wasm\"] = wasmExports[\"ts_tree_cursor_current_node_wasm\"];\n\nvar _ts_node_symbol_wasm = Module[\"_ts_node_symbol_wasm\"] = wasmExports[\"ts_node_symbol_wasm\"];\n\nvar _ts_node_field_name_for_child_wasm = Module[\"_ts_node_field_name_for_child_wasm\"] = wasmExports[\"ts_node_field_name_for_child_wasm\"];\n\nvar _ts_node_field_name_for_named_child_wasm = Module[\"_ts_node_field_name_for_named_child_wasm\"] = wasmExports[\"ts_node_field_name_for_named_child_wasm\"];\n\nvar _ts_node_children_by_field_id_wasm = Module[\"_ts_node_children_by_field_id_wasm\"] = wasmExports[\"ts_node_children_by_field_id_wasm\"];\n\nvar _ts_node_first_child_for_byte_wasm = Module[\"_ts_node_first_child_for_byte_wasm\"] = wasmExports[\"ts_node_first_child_for_byte_wasm\"];\n\nvar _ts_node_first_named_child_for_byte_wasm = Module[\"_ts_node_first_named_child_for_byte_wasm\"] = wasmExports[\"ts_node_first_named_child_for_byte_wasm\"];\n\nvar _ts_node_grammar_symbol_wasm = Module[\"_ts_node_grammar_symbol_wasm\"] = wasmExports[\"ts_node_grammar_symbol_wasm\"];\n\nvar _ts_node_child_count_wasm = Module[\"_ts_node_child_count_wasm\"] = wasmExports[\"ts_node_child_count_wasm\"];\n\nvar _ts_node_named_child_count_wasm = Module[\"_ts_node_named_child_count_wasm\"] = wasmExports[\"ts_node_named_child_count_wasm\"];\n\nvar _ts_node_child_wasm = Module[\"_ts_node_child_wasm\"] = wasmExports[\"ts_node_child_wasm\"];\n\nvar _ts_node_named_child_wasm = Module[\"_ts_node_named_child_wasm\"] = wasmExports[\"ts_node_named_child_wasm\"];\n\nvar _ts_node_child_by_field_id_wasm = Module[\"_ts_node_child_by_field_id_wasm\"] = wasmExports[\"ts_node_child_by_field_id_wasm\"];\n\nvar _ts_node_next_sibling_wasm = Module[\"_ts_node_next_sibling_wasm\"] = wasmExports[\"ts_node_next_sibling_wasm\"];\n\nvar _ts_node_prev_sibling_wasm = Module[\"_ts_node_prev_sibling_wasm\"] = wasmExports[\"ts_node_prev_sibling_wasm\"];\n\nvar _ts_node_next_named_sibling_wasm = Module[\"_ts_node_next_named_sibling_wasm\"] = wasmExports[\"ts_node_next_named_sibling_wasm\"];\n\nvar _ts_node_prev_named_sibling_wasm = Module[\"_ts_node_prev_named_sibling_wasm\"] = wasmExports[\"ts_node_prev_named_sibling_wasm\"];\n\nvar _ts_node_descendant_count_wasm = Module[\"_ts_node_descendant_count_wasm\"] = wasmExports[\"ts_node_descendant_count_wasm\"];\n\nvar _ts_node_parent_wasm = Module[\"_ts_node_parent_wasm\"] = wasmExports[\"ts_node_parent_wasm\"];\n\nvar _ts_node_child_with_descendant_wasm = Module[\"_ts_node_child_with_descendant_wasm\"] = wasmExports[\"ts_node_child_with_descendant_wasm\"];\n\nvar _ts_node_descendant_for_index_wasm = Module[\"_ts_node_descendant_for_index_wasm\"] = wasmExports[\"ts_node_descendant_for_index_wasm\"];\n\nvar _ts_node_named_descendant_for_index_wasm = Module[\"_ts_node_named_descendant_for_index_wasm\"] = wasmExports[\"ts_node_named_descendant_for_index_wasm\"];\n\nvar _ts_node_descendant_for_position_wasm = Module[\"_ts_node_descendant_for_position_wasm\"] = wasmExports[\"ts_node_descendant_for_position_wasm\"];\n\nvar _ts_node_named_descendant_for_position_wasm = Module[\"_ts_node_named_descendant_for_position_wasm\"] = wasmExports[\"ts_node_named_descendant_for_position_wasm\"];\n\nvar _ts_node_start_point_wasm = Module[\"_ts_node_start_point_wasm\"] = wasmExports[\"ts_node_start_point_wasm\"];\n\nvar _ts_node_end_point_wasm = Module[\"_ts_node_end_point_wasm\"] = wasmExports[\"ts_node_end_point_wasm\"];\n\nvar _ts_node_start_index_wasm = Module[\"_ts_node_start_index_wasm\"] = wasmExports[\"ts_node_start_index_wasm\"];\n\nvar _ts_node_end_index_wasm = Module[\"_ts_node_end_index_wasm\"] = wasmExports[\"ts_node_end_index_wasm\"];\n\nvar _ts_node_to_string_wasm = Module[\"_ts_node_to_string_wasm\"] = wasmExports[\"ts_node_to_string_wasm\"];\n\nvar _ts_node_children_wasm = Module[\"_ts_node_children_wasm\"] = wasmExports[\"ts_node_children_wasm\"];\n\nvar _ts_node_named_children_wasm = Module[\"_ts_node_named_children_wasm\"] = wasmExports[\"ts_node_named_children_wasm\"];\n\nvar _ts_node_descendants_of_type_wasm = Module[\"_ts_node_descendants_of_type_wasm\"] = wasmExports[\"ts_node_descendants_of_type_wasm\"];\n\nvar _ts_node_is_named_wasm = Module[\"_ts_node_is_named_wasm\"] = wasmExports[\"ts_node_is_named_wasm\"];\n\nvar _ts_node_has_changes_wasm = Module[\"_ts_node_has_changes_wasm\"] = wasmExports[\"ts_node_has_changes_wasm\"];\n\nvar _ts_node_has_error_wasm = Module[\"_ts_node_has_error_wasm\"] = wasmExports[\"ts_node_has_error_wasm\"];\n\nvar _ts_node_is_error_wasm = Module[\"_ts_node_is_error_wasm\"] = wasmExports[\"ts_node_is_error_wasm\"];\n\nvar _ts_node_is_missing_wasm = Module[\"_ts_node_is_missing_wasm\"] = wasmExports[\"ts_node_is_missing_wasm\"];\n\nvar _ts_node_is_extra_wasm = Module[\"_ts_node_is_extra_wasm\"] = wasmExports[\"ts_node_is_extra_wasm\"];\n\nvar _ts_node_parse_state_wasm = Module[\"_ts_node_parse_state_wasm\"] = wasmExports[\"ts_node_parse_state_wasm\"];\n\nvar _ts_node_next_parse_state_wasm = Module[\"_ts_node_next_parse_state_wasm\"] = wasmExports[\"ts_node_next_parse_state_wasm\"];\n\nvar _ts_query_matches_wasm = Module[\"_ts_query_matches_wasm\"] = wasmExports[\"ts_query_matches_wasm\"];\n\nvar _ts_query_captures_wasm = Module[\"_ts_query_captures_wasm\"] = wasmExports[\"ts_query_captures_wasm\"];\n\nvar _memset = Module[\"_memset\"] = wasmExports[\"memset\"];\n\nvar _memcpy = Module[\"_memcpy\"] = wasmExports[\"memcpy\"];\n\nvar _memmove = Module[\"_memmove\"] = wasmExports[\"memmove\"];\n\nvar _iswalpha = Module[\"_iswalpha\"] = wasmExports[\"iswalpha\"];\n\nvar _iswblank = Module[\"_iswblank\"] = wasmExports[\"iswblank\"];\n\nvar _iswdigit = Module[\"_iswdigit\"] = wasmExports[\"iswdigit\"];\n\nvar _iswlower = Module[\"_iswlower\"] = wasmExports[\"iswlower\"];\n\nvar _iswupper = Module[\"_iswupper\"] = wasmExports[\"iswupper\"];\n\nvar _iswxdigit = Module[\"_iswxdigit\"] = wasmExports[\"iswxdigit\"];\n\nvar _memchr = Module[\"_memchr\"] = wasmExports[\"memchr\"];\n\nvar _strlen = Module[\"_strlen\"] = wasmExports[\"strlen\"];\n\nvar _strcmp = Module[\"_strcmp\"] = wasmExports[\"strcmp\"];\n\nvar _strncat = Module[\"_strncat\"] = wasmExports[\"strncat\"];\n\nvar _strncpy = Module[\"_strncpy\"] = wasmExports[\"strncpy\"];\n\nvar _towlower = Module[\"_towlower\"] = wasmExports[\"towlower\"];\n\nvar _towupper = Module[\"_towupper\"] = wasmExports[\"towupper\"];\n\nvar _setThrew = wasmExports[\"setThrew\"];\n\nvar __emscripten_stack_restore = wasmExports[\"_emscripten_stack_restore\"];\n\nvar __emscripten_stack_alloc = wasmExports[\"_emscripten_stack_alloc\"];\n\nvar _emscripten_stack_get_current = wasmExports[\"emscripten_stack_get_current\"];\n\nvar ___wasm_apply_data_relocs = wasmExports[\"__wasm_apply_data_relocs\"];\n\n// include: postamble.js\n// === Auto-generated postamble setup entry stuff ===\nModule[\"setValue\"] = setValue;\n\nModule[\"getValue\"] = getValue;\n\nModule[\"UTF8ToString\"] = UTF8ToString;\n\nModule[\"stringToUTF8\"] = stringToUTF8;\n\nModule[\"lengthBytesUTF8\"] = lengthBytesUTF8;\n\nModule[\"AsciiToString\"] = AsciiToString;\n\nModule[\"stringToUTF16\"] = stringToUTF16;\n\nModule[\"loadWebAssemblyModule\"] = loadWebAssemblyModule;\n\nfunction callMain(args = []) {\n  var entryFunction = resolveGlobalSymbol(\"main\").sym;\n  // Main modules can't tell if they have main() at compile time, since it may\n  // arrive from a dynamic library.\n  if (!entryFunction) return;\n  args.unshift(thisProgram);\n  var argc = args.length;\n  var argv = stackAlloc((argc + 1) * 4);\n  var argv_ptr = argv;\n  args.forEach(arg => {\n    LE_HEAP_STORE_U32(((argv_ptr) >> 2) * 4, stringToUTF8OnStack(arg));\n    argv_ptr += 4;\n  });\n  LE_HEAP_STORE_U32(((argv_ptr) >> 2) * 4, 0);\n  try {\n    var ret = entryFunction(argc, argv);\n    // if we're not running an evented main loop, it's time to exit\n    exitJS(ret, /* implicit = */ true);\n    return ret;\n  } catch (e) {\n    return handleException(e);\n  }\n}\n\nfunction run(args = arguments_) {\n  if (runDependencies > 0) {\n    dependenciesFulfilled = run;\n    return;\n  }\n  preRun();\n  // a preRun added a dependency, run will be called later\n  if (runDependencies > 0) {\n    dependenciesFulfilled = run;\n    return;\n  }\n  function doRun() {\n    // run may have just been called through dependencies being fulfilled just in this very frame,\n    // or while the async setStatus time below was happening\n    Module[\"calledRun\"] = true;\n    if (ABORT) return;\n    initRuntime();\n    preMain();\n    readyPromiseResolve(Module);\n    Module[\"onRuntimeInitialized\"]?.();\n    var noInitialRun = Module[\"noInitialRun\"];\n    if (!noInitialRun) callMain(args);\n    postRun();\n  }\n  if (Module[\"setStatus\"]) {\n    Module[\"setStatus\"](\"Running...\");\n    setTimeout(() => {\n      setTimeout(() => Module[\"setStatus\"](\"\"), 1);\n      doRun();\n    }, 1);\n  } else {\n    doRun();\n  }\n}\n\nif (Module[\"preInit\"]) {\n  if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [ Module[\"preInit\"] ];\n  while (Module[\"preInit\"].length > 0) {\n    Module[\"preInit\"].pop()();\n  }\n}\n\nrun();\n\n// end include: postamble.js\n// include: postamble_modularize.js\n// In MODULARIZE mode we wrap the generated code in a factory function\n// and return either the Module itself, or a promise of the module.\n// We assign to the `moduleRtn` global here and configure closure to see\n// this as and extern so it won't get minified.\nmoduleRtn = readyPromise;\n\n\n  return moduleRtn;\n}\n);\n})();\nexport default Module;\n","import createModule, { type MainModule } from '../lib/tree-sitter';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { type Parser } from './parser';\n\nexport let Module: MainModule | null = null;\n\n/**\n * @internal\n *\n * Initialize the Tree-sitter WASM module. This should only be called by the {@link Parser} class via {@link Parser.init}.\n */\nexport async function initializeBinding(moduleOptions?: EmscriptenModule): Promise<MainModule> {\n  if (!Module) {\n    Module = await createModule(moduleOptions);\n  }\n  return Module;\n}\n\n/**\n * @internal\n *\n * Checks if the Tree-sitter WASM module has been initialized.\n */\nexport function checkModule(): boolean {\n  return !!Module;\n}\n","import { C, INTERNAL, LogCallback, ParseCallback, Range, SIZE_OF_INT, SIZE_OF_RANGE, setModule } from './constants';\nimport { Language } from './language';\nimport { marshalRange, unmarshalRange } from './marshal';\nimport { checkModule, initializeBinding } from './bindings';\nimport { Tree } from './tree';\n\n/**\n * Options for parsing\n *\n * The `includedRanges` property is an array of {@link Range} objects that\n * represent the ranges of text that the parser should include when parsing.\n *\n * The `progressCallback` property is a function that is called periodically\n * during parsing to check whether parsing should be cancelled.\n *\n * See {@link Parser#parse} for more information.\n */\nexport interface ParseOptions {\n  /**\n   * An array of {@link Range} objects that\n   * represent the ranges of text that the parser should include when parsing.\n   *\n   * This sets the ranges of text that the parser should include when parsing.\n   * By default, the parser will always include entire documents. This\n   * function allows you to parse only a *portion* of a document but\n   * still return a syntax tree whose ranges match up with the document\n   * as a whole. You can also pass multiple disjoint ranges.\n   * If `ranges` is empty, then the entire document will be parsed.\n   * Otherwise, the given ranges must be ordered from earliest to latest\n   * in the document, and they must not overlap. That is, the following\n   * must hold for all `i` < `length - 1`:\n   * ```text\n   *     ranges[i].end_byte <= ranges[i + 1].start_byte\n   * ```\n   */\n  includedRanges?: Range[];\n\n  /**\n   * A function that is called periodically during parsing to check\n   * whether parsing should be cancelled. If the progress callback returns\n   * `true`, then parsing will be cancelled. You can also use this to instrument\n   * parsing and check where the parser is at in the document. The progress callback\n   * takes a single argument, which is a {@link ParseState} representing the current\n   * state of the parser.\n   */\n  progressCallback?: (state: ParseState) => void;\n}\n\n/**\n * A stateful object that is passed into the progress callback {@link ParseOptions#progressCallback}\n * to provide the current state of the parser.\n */\nexport interface ParseState {\n  /** The byte offset in the document that the parser is at. */\n  currentOffset: number;\n\n  /** Indicates whether the parser has encountered an error during parsing. */\n  hasError: boolean;\n}\n\n/**\n * @internal\n *\n * Global variable for transferring data across the FFI boundary\n */\nexport let TRANSFER_BUFFER: number;\n\n/**\n * The latest ABI version that is supported by the current version of the\n * library.\n *\n * When Languages are generated by the Tree-sitter CLI, they are\n * assigned an ABI version number that corresponds to the current CLI version.\n * The Tree-sitter library is generally backwards-compatible with languages\n * generated using older CLI versions, but is not forwards-compatible.\n */\nexport let LANGUAGE_VERSION: number;\n\n/**\n * The earliest ABI version that is supported by the current version of the\n * library.\n */\nexport let MIN_COMPATIBLE_VERSION: number;\n\n/**\n * A stateful object that is used to produce a {@link Tree} based on some\n * source code.\n */\nexport class Parser {\n  /** @internal */\n  private [0] = 0; // Internal handle for WASM\n\n  /** @internal */\n  private [1] = 0; // Internal handle for WASM\n\n  /** @internal */\n  private logCallback: LogCallback | null = null;\n\n  /** The parser's current language. */\n  language: Language | null = null;\n\n  /**\n   * This must always be called before creating a Parser.\n   *\n   * You can optionally pass in options to configure the WASM module, the most common\n   * one being `locateFile` to help the module find the `.wasm` file.\n   */\n  static async init(moduleOptions?: EmscriptenModule) {\n    setModule(await initializeBinding(moduleOptions));\n    TRANSFER_BUFFER = C._ts_init();\n    LANGUAGE_VERSION = C.getValue(TRANSFER_BUFFER, 'i32');\n    MIN_COMPATIBLE_VERSION = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n  }\n\n  /**\n   * Create a new parser.\n   */\n  constructor() {\n    this.initialize();\n  }\n\n  /** @internal */\n  initialize() {\n    if (!checkModule()) {\n      throw new Error(\"cannot construct a Parser before calling `init()`\");\n    }\n    C._ts_parser_new_wasm();\n    this[0] = C.getValue(TRANSFER_BUFFER, 'i32');\n    this[1] = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n  }\n\n  /** Delete the parser, freeing its resources. */\n  delete() {\n    C._ts_parser_delete(this[0]);\n    C._free(this[1]);\n    this[0] = 0;\n    this[1] = 0;\n  }\n\n  /**\n   * Set the language that the parser should use for parsing.\n   *\n   * If the language was not successfully assigned, an error will be thrown.\n   * This happens if the language was generated with an incompatible\n   * version of the Tree-sitter CLI. Check the language's version using\n   * {@link Language#version} and compare it to this library's\n   * {@link LANGUAGE_VERSION} and {@link MIN_COMPATIBLE_VERSION} constants.\n   */\n  setLanguage(language: Language | null): this {\n    let address: number;\n    if (!language) {\n      address = 0;\n      this.language = null;\n    } else if (language.constructor === Language) {\n      address = language[0];\n      const version = C._ts_language_version(address);\n      if (version < MIN_COMPATIBLE_VERSION || LANGUAGE_VERSION < version) {\n        throw new Error(\n          `Incompatible language version ${version}. ` +\n          `Compatibility range ${MIN_COMPATIBLE_VERSION} through ${LANGUAGE_VERSION}.`\n        );\n      }\n      this.language = language;\n    } else {\n      throw new Error('Argument must be a Language');\n    }\n\n    C._ts_parser_set_language(this[0], address);\n    return this;\n  }\n\n  /**\n   * Parse a slice of UTF8 text.\n   *\n   * @param {string | ParseCallback} callback - The UTF8-encoded text to parse or a callback function.\n   *\n   * @param {Tree | null} [oldTree] - A previous syntax tree parsed from the same document. If the text of the\n   *   document has changed since `oldTree` was created, then you must edit `oldTree` to match\n   *   the new text using {@link Tree#edit}.\n   *\n   * @param {ParseOptions} [options] - Options for parsing the text.\n   *  This can be used to set the included ranges, or a progress callback.\n   *\n   * @returns {Tree | null} A {@link Tree} if parsing succeeded, or `null` if:\n   *  - The parser has not yet had a language assigned with {@link Parser#setLanguage}.\n   *  - The progress callback returned true.\n   */\n  parse(\n    callback: string | ParseCallback,\n    oldTree?: Tree | null,\n    options?: ParseOptions,\n  ): Tree | null {\n    if (typeof callback === 'string') {\n      C.currentParseCallback = (index: number) => callback.slice(index);\n    } else if (typeof callback === 'function') {\n      C.currentParseCallback = callback;\n    } else {\n      throw new Error('Argument must be a string or a function');\n    }\n\n    if (options?.progressCallback) {\n      C.currentProgressCallback = options.progressCallback;\n    } else {\n      C.currentProgressCallback = null;\n    }\n\n    if (this.logCallback) {\n      C.currentLogCallback = this.logCallback;\n      C._ts_parser_enable_logger_wasm(this[0], 1);\n    } else {\n      C.currentLogCallback = null;\n      C._ts_parser_enable_logger_wasm(this[0], 0);\n    }\n\n    let rangeCount = 0;\n    let rangeAddress = 0;\n    if (options?.includedRanges) {\n      rangeCount = options.includedRanges.length;\n      rangeAddress = C._calloc(rangeCount, SIZE_OF_RANGE);\n      let address = rangeAddress;\n      for (let i = 0; i < rangeCount; i++) {\n        marshalRange(address, options.includedRanges[i]);\n        address += SIZE_OF_RANGE;\n      }\n    }\n\n    const treeAddress = C._ts_parser_parse_wasm(\n      this[0],\n      this[1],\n      oldTree ? oldTree[0] : 0,\n      rangeAddress,\n      rangeCount\n    );\n\n    if (!treeAddress) {\n      C.currentParseCallback = null;\n      C.currentLogCallback = null;\n      C.currentProgressCallback = null;\n      return null;\n    }\n\n    if (!this.language) {\n      throw new Error('Parser must have a language to parse');\n    }\n\n    const result = new Tree(INTERNAL, treeAddress, this.language, C.currentParseCallback);\n    C.currentParseCallback = null;\n    C.currentLogCallback = null;\n    C.currentProgressCallback = null;\n    return result;\n  }\n\n  /**\n   * Instruct the parser to start the next parse from the beginning.\n   *\n   * If the parser previously failed because of a timeout, cancellation,\n   * or callback, then by default, it will resume where it left off on the\n   * next call to {@link Parser#parse} or other parsing functions.\n   * If you don't want to resume, and instead intend to use this parser to\n   * parse some other document, you must call `reset` first.\n   */\n  reset(): void {\n    C._ts_parser_reset(this[0]);\n  }\n\n  /** Get the ranges of text that the parser will include when parsing. */\n  getIncludedRanges(): Range[] {\n    C._ts_parser_included_ranges_wasm(this[0]);\n    const count = C.getValue(TRANSFER_BUFFER, 'i32');\n    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n    const result = new Array<Range>(count);\n\n    if (count > 0) {\n      let address = buffer;\n      for (let i = 0; i < count; i++) {\n        result[i] = unmarshalRange(address);\n        address += SIZE_OF_RANGE;\n      }\n      C._free(buffer);\n    }\n\n    return result;\n  }\n\n  /**\n   * @deprecated since version 0.25.0, prefer passing a progress callback to {@link Parser#parse}\n   *\n   * Get the duration in microseconds that parsing is allowed to take.\n   *\n   * This is set via {@link Parser#setTimeoutMicros}.\n   */\n  getTimeoutMicros(): number {\n    return C._ts_parser_timeout_micros(this[0]);\n  }\n\n  /**\n   * @deprecated since version 0.25.0, prefer passing a progress callback to {@link Parser#parse}\n   *\n   * Set the maximum duration in microseconds that parsing should be allowed\n   * to take before halting.\n   *\n   * If parsing takes longer than this, it will halt early, returning `null`.\n   * See {@link Parser#parse} for more information.\n   */\n  setTimeoutMicros(timeout: number): void {\n    C._ts_parser_set_timeout_micros(this[0], 0, timeout);\n  }\n\n  /** Set the logging callback that a parser should use during parsing. */\n  setLogger(callback: LogCallback | boolean | null): this {\n    if (!callback) {\n      this.logCallback = null;\n    } else if (typeof callback !== 'function') {\n      throw new Error('Logger callback must be a function');\n    } else {\n      this.logCallback = callback;\n    }\n    return this;\n  }\n\n  /** Get the parser's current logger. */\n  getLogger(): LogCallback | null {\n    return this.logCallback;\n  }\n}\n","function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nexport { _typeof as default };","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nexport { toPropertyKey as default };","import _typeof from \"./typeof.js\";\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nexport { toPrimitive as default };","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nexport { _defineProperty as default };"],"names":["SIZE_OF_SHORT","SIZE_OF_INT","SIZE_OF_CURSOR","SIZE_OF_NODE","SIZE_OF_POINT","SIZE_OF_RANGE","ZERO_POINT","row","column","INTERNAL","Symbol","C","assertInternal","x","Error","isPoint","point","setModule","module2","__name","LookaheadIterator","_Class","constructor","internal","address","language","_defineProperty","this","currentTypeId","_ts_lookahead_iterator_current_symbol","currentType","types","delete","_ts_lookahead_iterator_delete","reset","stateId","_ts_lookahead_iterator_reset","resetState","Boolean","_ts_lookahead_iterator_reset_state","iterator","next","_ts_lookahead_iterator_next","done","value","getText","tree","startIndex","endIndex","startPosition","length","result","textCallback","string","slice","Tree","_Tree2","_Tree","copy","_ts_tree_copy","_ts_tree_delete","rootNode","_ts_tree_root_node_wasm","unmarshalNode","rootNodeWithOffset","offsetBytes","offsetExtent","TRANSFER_BUFFER","setValue","marshalPoint","_ts_tree_root_node_with_offset_wasm","edit","marshalEdit","_ts_tree_edit_wasm","walk","getChangedRanges","other","TypeError","_ts_tree_get_changed_ranges_wasm","count","getValue","buffer","Array","i2","unmarshalRange","_free","getIncludedRanges","_ts_tree_included_ranges_wasm","TreeCursor","_TreeCursor2","_TreeCursor","unmarshalTreeCursor","_ts_tree_cursor_copy_wasm","marshalTreeCursor","_ts_tree_cursor_delete_wasm","currentNode","_ts_tree_cursor_current_node_wasm","currentFieldId","_ts_tree_cursor_current_field_id_wasm","currentFieldName","fields","currentDepth","_ts_tree_cursor_current_depth_wasm","currentDescendantIndex","_ts_tree_cursor_current_descendant_index_wasm","nodeType","nodeTypeId","_ts_tree_cursor_current_node_type_id_wasm","nodeStateId","_ts_tree_cursor_current_node_state_id_wasm","nodeId","_ts_tree_cursor_current_node_id_wasm","nodeIsNamed","_ts_tree_cursor_current_node_is_named_wasm","nodeIsMissing","_ts_tree_cursor_current_node_is_missing_wasm","nodeText","_ts_tree_cursor_start_index_wasm","_ts_tree_cursor_end_index_wasm","_ts_tree_cursor_start_position_wasm","unmarshalPoint","endPosition","_ts_tree_cursor_end_position_wasm","gotoFirstChild","_ts_tree_cursor_goto_first_child_wasm","gotoLastChild","_ts_tree_cursor_goto_last_child_wasm","gotoParent","_ts_tree_cursor_goto_parent_wasm","gotoNextSibling","_ts_tree_cursor_goto_next_sibling_wasm","gotoPreviousSibling","_ts_tree_cursor_goto_previous_sibling_wasm","gotoDescendant","goalDescendantIndex","_ts_tree_cursor_goto_descendant_wasm","gotoFirstChildForIndex","goalIndex","_ts_tree_cursor_goto_first_child_for_index_wasm","gotoFirstChildForPosition","goalPosition","_ts_tree_cursor_goto_first_child_for_position_wasm","node","marshalNode","_ts_tree_cursor_reset_wasm","resetTo","cursor","_ts_tree_cursor_reset_to_wasm","Node","_Class2","_ref","id","typeId","_ts_node_symbol_wasm","grammarId","_ts_node_grammar_symbol_wasm","type","grammarType","isNamed","_ts_node_is_named_wasm","isExtra","_ts_node_is_extra_wasm","isError","_ts_node_is_error_wasm","isMissing","_ts_node_is_missing_wasm","hasChanges","_ts_node_has_changes_wasm","hasError","_ts_node_has_error_wasm","_ts_node_end_index_wasm","_ts_node_end_point_wasm","text","parseState","_ts_node_parse_state_wasm","nextParseState","_ts_node_next_parse_state_wasm","equals","child","index","_ts_node_child_wasm","namedChild","_ts_node_named_child_wasm","childForFieldId","fieldId","_ts_node_child_by_field_id_wasm","childForFieldName","fieldName","indexOf","fieldNameForChild","_ts_node_field_name_for_child_wasm","AsciiToString","fieldNameForNamedChild","_ts_node_field_name_for_named_child_wasm","childrenForFieldName","childrenForFieldId","_ts_node_children_by_field_id_wasm","firstChildForIndex","_ts_node_first_child_for_byte_wasm","firstNamedChildForIndex","_ts_node_first_named_child_for_byte_wasm","childCount","_ts_node_child_count_wasm","namedChildCount","_ts_node_named_child_count_wasm","firstChild","firstNamedChild","lastChild","lastNamedChild","children","_children","_ts_node_children_wasm","namedChildren","_namedChildren","_ts_node_named_children_wasm","descendantsOfType","arguments","undefined","isArray","symbols","typesBySymbol","node_type","push","n","includes","symbolsAddress","_malloc","_ts_node_descendants_of_type_wasm","descendantCount","descendantAddress","nextSibling","_ts_node_next_sibling_wasm","previousSibling","_ts_node_prev_sibling_wasm","nextNamedSibling","_ts_node_next_named_sibling_wasm","previousNamedSibling","_ts_node_prev_named_sibling_wasm","_ts_node_descendant_count_wasm","parent","_ts_node_parent_wasm","childWithDescendant","descendant","_ts_node_child_with_descendant_wasm","descendantForIndex","start2","end","_ts_node_descendant_for_index_wasm","namedDescendantForIndex","_ts_node_named_descendant_for_index_wasm","descendantForPosition","_ts_node_descendant_for_position_wasm","namedDescendantForPosition","_ts_node_named_descendant_for_position_wasm","_ts_tree_cursor_new_wasm","oldEndIndex","subbedPointRow","subbedPointColumn","newEndIndex","oldEndPosition","newEndPosition","toString","_ts_node_to_string_wasm","unmarshalCaptures","query","patternIndex","captureIndex","name","captureNames","marshalRange","range","unmarshalLanguageMetadata","major_version","minor_version","patch_version","PREDICATE_STEP_TYPE_CAPTURE","PREDICATE_STEP_TYPE_STRING","QUERY_WORD_REGEX","CaptureQuantifier","Zero","ZeroOrOne","ZeroOrMore","One","OneOrMore","isCaptureStep","step","isStringStep","QueryErrorKind","Syntax","NodeName","FieldName","CaptureName","PatternStructure","QueryError","_QueryError2","_QueryError","kind","info2","super","formatMessage","info","concat","word","suffix","parseAnyPredicate","steps","operator","textPredicates","isPositive","matchAll","startsWith","captureName1","captureName2","captures","nodes1","nodes2","c","compare","n1","n2","positive","every","some","captureName","stringValue","matches","doesNotMatch","nodes","test","parseMatchPredicate","regex","RegExp","parseAnyOfPredicate","stringSteps","values","map","s","parseIsPredicate","assertedProperties","refutedProperties","_steps$2$value","_steps$","properties","parseSetDirective","setProperties","_steps$2$value2","_steps$2","parsePattern","stepType","stepValueId","stringValues","predicates","name2","operands","Query","_Class3","source","sourceLength","lengthBytesUTF8","sourceAddress","stringToUTF8","_ts_query_new","_suffix$match$","_suffix$match","errorId","errorByte","errorIndex","UTF8ToString","split","match","stringCount","_ts_query_string_count","captureCount","_ts_query_capture_count","patternCount","_ts_query_pattern_count","captureQuantifiers","nameAddress","_ts_query_capture_name_for_id","nameLength","captureQuantifiersArray","j","quantifier","_ts_query_capture_quantifier_for_id","valueAddress","_ts_query_string_value_for_id","predicatesAddress","_ts_query_predicates_for_pattern","stepCount","stepAddress","Object","freeze","exceededMatchLimit","_ts_query_delete","_options$startPositio","_options$endPosition","_options$startIndex","_options$endIndex","_options$matchLimit","_options$maxStartDept","_options$timeoutMicro","options","matchLimit","maxStartDepth","timeoutMicros","progressCallback","currentQueryProgressCallback","_ts_query_matches_wasm","rawCount","startAddress","didExceedMatchLimit","filteredCount","p","pattern","_options$startPositio2","_options$endPosition2","_options$startIndex2","_options$endIndex2","_options$matchLimit2","_options$maxStartDept2","_options$timeoutMicro2","_ts_query_captures_wasm","capture","predicatesForPattern","disableCapture","captureNameLength","captureNameAddress","_ts_query_disable_capture","disablePattern","_ts_query_disable_pattern","startIndexForPattern","_ts_query_start_byte_for_pattern","endIndexForPattern","_ts_query_end_byte_for_pattern","captureIndexForName","isPatternRooted","_ts_query_is_pattern_rooted","isPatternNonLocal","_ts_query_is_pattern_non_local","isPatternGuaranteedAtStep","byteIndex","_ts_query_is_pattern_guaranteed_at_step","LANGUAGE_FUNCTION_REGEX","Language","_Language2","_Language","_ts_language_symbol_count","_ts_language_symbol_type","_ts_language_symbol_name","_ts_language_field_count","_ts_language_field_name_for_id","ptr","_ts_language_name","version","_ts_language_version","abiVersion","_ts_language_abi_version","metadata","_ts_language_metadata","fieldCount","stateCount","_ts_language_state_count","fieldIdForName","fieldNameForId","_this$fields$fieldId","idForNodeType","named","typeLength","typeAddress","_ts_language_symbol_for_name","nodeTypeCount","nodeTypeForId","nodeTypeIsNamed","_ts_language_type_is_named_wasm","nodeTypeIsVisible","_ts_language_type_is_visible_wasm","supertypes","_ts_language_supertypes_wasm","subtypes","supertype","_ts_language_subtypes_wasm","nextState","_ts_language_next_state","lookaheadIterator","_ts_lookahead_iterator_new","console","warn","load","input","bytes","_globalThis$process","Uint8Array","Promise","resolve","globalThis","process","versions","readFile","fetch","then","response","arrayBuffer","ok","body2","TextDecoder","decode","status","mod","loadWebAssemblyModule","loadAsync","symbolNames","keys","functionName","find","key","log","JSON","stringify","languageAddress","Module2","_scriptName","import","async","_ExitStatus","moduleArg","moduleRtn","Module","readyPromiseResolve","readyPromiseReject","readyPromise","reject","ENVIRONMENT_IS_WEB","window","ENVIRONMENT_IS_WORKER","WorkerGlobalScope","ENVIRONMENT_IS_NODE","ENVIRONMENT_IS_SHELL","createRequire","require","currentProgressCallback","currentLogCallback","currentParseCallback","moduleOverrides","assign","arguments_","thisProgram","quit_","toThrow","scriptDirectory","readAsync","readBinary","locateFile","path","fs","nodePath","dirname","fileURLToPath","filename","isFileURI","URL","readFileSync","binary2","argv","replace","exitCode","self","location","href","document","currentScript","src","lastIndexOf","url","xhr","XMLHttpRequest","open","responseType","send","onload","onerror","credentials","out","bind","err","error","dynamicLibraries","wasmBinary","wasmMemory","ABORT","EXITSTATUS","HEAP","HEAP8","HEAPU8","HEAP16","HEAPU16","HEAP32","HEAPU32","HEAPF32","HEAP64","HEAPU64","HEAPF64","HEAP_DATA_VIEW","assert","condition","abort","runtimeInitialized","updateMemoryViews","b","DataView","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array","INITIAL_MEMORY","WebAssembly","Memory","__RELOC_FUNCS__","preRun","addOnPreRun","shift","callRuntimeCallbacks","onPreRuns","initRuntime","wasmExports","onPostCtors","preMain","postRun","addOnPostRun","onPostRuns","runDependencies","dependenciesFulfilled","wasmBinaryFile","getUniqueRunDependency","addRunDependency","_Module$monitorRunDep","call","removeRunDependency","_Module$monitorRunDep2","callback","what","_Module$onAbort","e","RuntimeError","findWasmBinary","getBinarySync","file","getWasmBinary","binaryFile","_unused","instantiateArrayBuffer","imports","instantiate","reason","instantiateAsync","instantiateStreaming","getWasmImports","wasmImports","Proxy","GOTHandler","createWasm","receiveInstance","instance2","exports","relocateExports","metadata2","getDylinkMetadata","neededDynlibs","mergeLibSymbols","LDSO","init","loadDylibs","receiveInstantiationResult","result2","inst","ASM_CONSTS","ExitStatus","message","GOT","currentModuleWeakSymbols","Set","get","obj","symName","rtn","Global","has","required","LE_HEAP_LOAD_F32","byteOffset","getFloat32","LE_HEAP_LOAD_F64","getFloat64","LE_HEAP_LOAD_I16","getInt16","LE_HEAP_LOAD_I32","getInt32","LE_HEAP_LOAD_U16","getUint16","LE_HEAP_LOAD_U32","getUint32","LE_HEAP_STORE_F32","setFloat32","LE_HEAP_STORE_F64","setFloat64","LE_HEAP_STORE_I16","setInt16","LE_HEAP_STORE_I32","setInt32","LE_HEAP_STORE_U16","setUint16","LE_HEAP_STORE_U32","setUint32","callbacks","cb","unshift","UTF8Decoder","UTF8ArrayToString","heapOrArray","idx","endIdx","NaN","endPtr","subarray","str","u0","u1","u2","String","fromCharCode","ch","offset","getU8","getLEB","ret","mul","byte","getString","len","failIf","dylinkSection","customSections","int32View","section_size","customSection","tlsExports","weakImports","memorySize","memoryAlign","tableSize","tableAlign","neededDynlibsCount","libname","subsectionType","subsectionSize","symname","add","endsWith","newDSO","handle2","syms","dso","refcount","Infinity","global","loadedLibsByName","loadedLibsByHandle","___heap_base","alignMemory","size","alignment","Math","ceil","getMemory","_calloc","isInternalSym","uleb128Encode","target","sigToWasmTypes","sig","typeNames","parameters","results","generateFuncType","sigRet","sigParam","typeCodes","convertJsFunctionToWasm","func2","Function","typeSectionBody","Instance","wasmTableMirror","wasmTable","Table","getWasmTableEntry","funcPtr","updateTableMap","functionsInTableMap","item","set","getFunctionAddress","WeakMap","freeTableIndexes","getEmptyTableSlot","pop","grow","err2","RangeError","setWasmTableEntry","addFunction","wrapped","updateGOT","_symName","memoryBase2","relocated","isSymbolDefined","existing","stub","dynCall","args2","stackSave","_emscripten_stack_get_current","stackRestore","val","__emscripten_stack_restore","createInvokeFunction","sp","_len","_key","_setThrew","resolveGlobalSymbol","sym","addOnPostCtor","maxBytesToRead","binary","flags","libName","localScope","handle","loadModule","memAlign","pow","memoryBase","tableBase","moduleExports","resolveSymbol","resolved","proxyHandler","stubs","prop","proxy","postInstantiation","module","instance","addEmAsm","addr","body","args","arity","join","func","start","eval","allowUndefined","reportUndefinedSymbols","stop","jsString","addEmJs","cSig","jsArgs","i","jsArg","parts","applyRelocs","reduce","chain","dynNeeded","loadDynamicLibrary","forEach","needed","libName2","exp","entries","setImport","main_alias","asyncLoad","flags2","nodelete","localScope2","loadLibData","data","dataSize","libData","libFile","getExports","moduleLoaded","entry","lib","noExitRuntime","BigInt","___memory_base","___stack_pointer","___table_base","__abort_js","_emscripten_get_now","performance","now","_emscripten_date_now","Date","nowIsMonotonic","checkWasiClock","clock_id","INT53_MAX","INT53_MIN","bigintToI53Checked","num","Number","_clock_time_get","clk_id","ignored_precision","ptime","nsec","round","getHeapMax","growMemory","pages","byteLength","_emscripten_resize_heap","requestedSize","oldSize","maxHeapSize","cutDown","overGrownHeapSize","min","newSize","max","_fd_close","fd","_fd_seek","whence","newOffset","printCharBuffers","printChar","stream","curr","flush_NO_FILESYSTEM","SYSCALLS","varargs","getStr","_fd_write","iov","iovcnt","pnum","_tree_sitter_log_callback","isLexMessage","messageAddress","_tree_sitter_parse_callback","inputBufferAddress","lengthAddress","stringToUTF16","_tree_sitter_progress_callback","currentOffset","_tree_sitter_query_progress_callback","runtimeKeepaliveCounter","keepRuntimeAlive","_proc_exit","code","_Module$onExit","exitJS","implicit","handleException","charCodeAt","stringToUTF8Array","heap","outIdx","maxBytesToWrite","startIdx","u","outPtr","stackAlloc","sz","__emscripten_stack_alloc","stringToUTF8OnStack","startPtr","numCharsToWrite","codeUnit","__heap_base","__indirect_function_table","__memory_base","__stack_pointer","__table_base","_abort_js","clock_time_get","emscripten_resize_heap","fd_close","fd_seek","fd_write","memory","tree_sitter_log_callback","tree_sitter_parse_callback","tree_sitter_progress_callback","tree_sitter_query_progress_callback","___wasm_call_ctors","_realloc","_memcmp","_strncmp","_ts_parser_delete","_ts_parser_reset","_ts_parser_set_language","_ts_parser_timeout_micros","_ts_parser_set_timeout_micros","_ts_parser_set_included_ranges","_iswspace","_iswalnum","_ts_init","_ts_parser_new_wasm","_ts_parser_enable_logger_wasm","_ts_parser_parse_wasm","_ts_parser_included_ranges_wasm","_ts_node_start_point_wasm","_ts_node_start_index_wasm","_memset","_memcpy","_memmove","_iswalpha","_iswblank","_iswdigit","_iswlower","_iswupper","_iswxdigit","_memchr","_strlen","_strcmp","_strncat","_strncpy","_towlower","_towupper","___wasm_apply_data_relocs","callMain","entryFunction","argc","argv_ptr","arg","run","doRun","_Module$onRuntimeInit","setTimeout","tree_sitter_default","Module3","LANGUAGE_VERSION","MIN_COMPATIBLE_VERSION","initializeBinding","moduleOptions","checkModule","Parser","_Class4","initialize","setLanguage","parse","oldTree","logCallback","rangeCount","rangeAddress","includedRanges","treeAddress","getTimeoutMicros","setTimeoutMicros","timeout","setLogger","getLogger","_typeof","o","prototype","toPropertyKey","t","r","toPrimitive","defineProperty","enumerable","configurable","writable"],"sourceRoot":""}